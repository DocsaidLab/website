"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1510],{42245:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=t(74848),s=t(28453);const o={},r="[17.06] Transformer",a={id:"language-model/transformer/index",title:"[17.06] Transformer",description:"The Dawn of a New Era",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/language-model/1706-transformer/index.md",sourceDirName:"language-model/1706-transformer",slug:"/language-model/transformer/",permalink:"/en/papers/language-model/transformer/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1722902191e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"Language Model",permalink:"/en/papers/category/language-model"},next:{title:"[18.06] GPT-1",permalink:"/en/papers/language-model/gpt_1/"}},l={},d=[{value:"The Dawn of a New Era",id:"the-dawn-of-a-new-era",level:2},{value:"Defining the Problem",id:"defining-the-problem",level:2},{value:"1. Limitations of Recursive Calculations",id:"1-limitations-of-recursive-calculations",level:3},{value:"2. Long-Distance Dependency Problem",id:"2-long-distance-dependency-problem",level:3},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Model Design",id:"model-design",level:3},{value:"Input Layer",id:"input-layer",level:3},{value:"Positional Encoding",id:"positional-encoding",level:3},{value:"Self-Attention Mechanism",id:"self-attention-mechanism",level:3},{value:"Multi-Head Attention Mechanism",id:"multi-head-attention-mechanism",level:3},{value:"Cross-Attention Mechanism",id:"cross-attention-mechanism",level:3},{value:"Feed-Forward Network",id:"feed-forward-network",level:3},{value:"Layer Normalization",id:"layer-normalization",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Why Use Self-Attention?",id:"why-use-self-attention",level:3},{value:"Experimental Results: Machine Translation",id:"experimental-results-machine-translation",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"1706-transformer",children:"[17.06] Transformer"}),"\n",(0,i.jsx)(n.h2,{id:"the-dawn-of-a-new-era",children:"The Dawn of a New Era"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://arxiv.org/pdf/1706.03762",children:(0,i.jsx)(n.strong,{children:"Attention Is All You Need"})})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The following content has been compiled by ChatGPT-4 and manually proofread, edited, and supplemented."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Unlike previous sequential models, the Transformer model introduced a new era of self-attention mechanisms."}),"\n",(0,i.jsx)(n.p,{children:"This model no longer relies on recursive calculations of sequences but instead uses attention mechanisms for sequence modeling, making the training and inference processes more efficient."}),"\n",(0,i.jsx)(n.h2,{id:"defining-the-problem",children:"Defining the Problem"}),"\n",(0,i.jsx)(n.p,{children:"In past sequence modeling tasks, RNN and LSTM models were mainstream."}),"\n",(0,i.jsx)(n.p,{children:"However, these models faced several issues during training and inference:"}),"\n",(0,i.jsx)(n.h3,{id:"1-limitations-of-recursive-calculations",children:"1. Limitations of Recursive Calculations"}),"\n",(0,i.jsx)(n.p,{children:"RNN and LSTM models need to calculate each element of the sequence step-by-step during training, leading to serialized computations that hinder efficient parallel processing."}),"\n",(0,i.jsx)(n.h3,{id:"2-long-distance-dependency-problem",children:"2. Long-Distance Dependency Problem"}),"\n",(0,i.jsx)(n.p,{children:"Due to the recursive nature of RNN and LSTM models, they struggle to capture dependencies between distant positions in a sequence when processing long sequences."}),"\n",(0,i.jsx)(n.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,i.jsx)(n.h3,{id:"model-design",children:"Model Design"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Transformer Model Architecture",src:t(29538).A+"",width:"756",height:"1080"})}),"\n",(0,i.jsx)(n.p,{children:"This is the Transformer model architecture diagram provided in the original paper."}),"\n",(0,i.jsx)(n.p,{children:"Although this diagram is very concise (???), most people usually do not understand it at first glance."}),"\n",(0,i.jsx)(n.p,{children:"Believe it or not, this is already simplified!"}),"\n",(0,i.jsx)(n.p,{children:"Let's write a simple code snippet to see how this model actually works:"}),"\n",(0,i.jsx)(n.h3,{id:"input-layer",children:"Input Layer"}),"\n",(0,i.jsx)(n.p,{children:"Here, the input is a sequence of data, represented as a tensor."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["First dimension: Batch size, referred to as ",(0,i.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Second dimension: Sequence length, referred to as ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Third dimension: Feature dimension, referred to as ",(0,i.jsx)(n.code,{children:"D"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's start with a simple example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"input_text = ['\u4f60', '\u597d', '\u554a', '\u3002']\ninput_text_mapping = {\n    '\u4f60': 0,\n    '\u597d': 1,\n    '\u554a': 2,\n    '\u3002': 3\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:'In this example, the input text is "\u4f60\u597d\u554a\u3002", with a total of 4 characters.'}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Here, we greatly simplify the entire training process to make it easier for you to understand."})}),"\n",(0,i.jsx)(n.p,{children:"Next, convert this input into a tensor:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import torch\nimport torch.nn as nn\n\ninput_tensor = torch.tensor([\n    input_text_mapping[token]\n    for token in input_text]\n)\nprint(input_tensor)\n# >>> tensor([0, 1, 2, 3])\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next, we embed each element:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"embedding = nn.Embedding(num_embeddings=4, embedding_dim=512)\nembedded_input = embedding(input_tensor)\nprint(embedded_input)\n# >>> tensor([[ 0.1,  0.2,  0.3,  ...,  0.4],\n#             [ 0.5,  0.6,  0.7,  ...,  0.8],\n#             [ 0.9,  1.0,  1.1,  ...,  1.2],\n#             [ 1.3,  1.4,  1.5,  ...,  1.6]])\nprint(embedded_input.shape)\n# >>> torch.Size([4, 512])\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Embedding is not a complex technique; it simply projects each element into a higher-dimensional space using a linear transformation layer."})}),"\n",(0,i.jsx)(n.p,{children:"Finally, don't forget we need a 3D tensor as input, so we need to add a batch size dimension. In this example, the batch size is 1."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"embedded_input = embedded_input.unsqueeze(0)\nprint(embedded_input.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"positional-encoding",children:"Positional Encoding"}),"\n",(0,i.jsx)(n.p,{children:"In traditional RNN and LSTM models, the model captures sequence dependencies through the position of elements in the sequence."}),"\n",(0,i.jsx)(n.p,{children:"Therefore, we do not need special positional encoding, as the model implicitly includes positional information in each iteration of the For-Loop."}),"\n",(0,i.jsx)(n.p,{children:"However, the Transformer architecture lacks such implicit positional information; it only consists of linear transformation layers. In linear transformation layers, each element is independent with no intrinsic relationships. Hence, we need additional positional encoding to help the model capture positional dependencies in the sequence."}),"\n",(0,i.jsx)(n.p,{children:"In this paper, the authors propose a simple positional encoding method using sine and cosine functions:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Positional Encoding Formula",src:t(98765).A+"",width:"1036",height:"180"})}),"\n",(0,i.jsx)(n.p,{children:"Let's implement a positional encoding function based on the above formula:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import math\nimport torch\n\ndef sinusoidal_positional_encoding(length, dim):\n    """ Sinusoidal positional encoding for non-recurrent neural networks.\n        REFERENCES: Attention Is All You Need\n        URL: https://arxiv.org/abs/1706.03762\n    """\n    if dim % 2 != 0:\n        raise ValueError(\n            \'Cannot use sin/cos positional encoding with \'\n            f\'odd dim (got dim={dim})\')\n\n    # position embedding\n    pe = torch.zeros(length, dim)\n    position = torch.arange(0, length).unsqueeze(1)\n    div_term = torch.exp(\n        (torch.arange(0, dim, 2, dtype=torch.float) * -(math.log(10000.0) / dim)))\n    pe[:, 0::2] = torch.sin(position.float() * div_term)\n    pe[:, 1::2] = torch.cos(position.float() * div_term)\n\n    return pe\n'})}),"\n",(0,i.jsx)(n.p,{children:"This function considers both sequence length and feature dimensions, providing each position with a fixed positional encoding."}),"\n",(0,i.jsx)(n.p,{children:"Let's visualize the positional encoding, assuming a sequence length of 256 and a feature dimension of 512:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import cv2\nimport numpy as np\n\npos_mask = sinusoidal_positional_encoding(256, 512)\npos_mask = pos_mask.numpy()\npos_mask = (pos_mask-pos_mask.max()) / (pos_mask.max()-pos_mask.min())\npos_mask = np.array(pos_mask * 255).astype(np.uint8)\npos_mask = cv2.applyColorMap(pos_mask, cv2.COLORMAP_JET)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Positional Encoding Visualization",src:t(53872).A+"",width:"1024",height:"256"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What is the significance of the number 10000 in the formula?"})}),(0,i.jsx)(n.p,{children:"The number 10000 represents the scale of the positional encoding. By restricting the scale within a suitable range, it effectively captures the relationships between different positions while avoiding the adverse effects of excessively high or low frequencies."}),(0,i.jsx)(n.p,{children:"If the number 10000 is changed to 100, the frequencies of the sine and cosine functions increase, causing positional encodings to repeat over shorter distances. This might reduce the model's ability to perceive relationships between distant positions as their encodings will appear more similar."})]}),"\n",(0,i.jsx)(n.p,{children:"After obtaining the positional encoding, we need to add it to the input embedding tensor:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"pos_emb = sinusoidal_positional_encoding(4, 512)\nembedded_input = embedded_input + pos_emb\n"})}),"\n",(0,i.jsx)(n.h3,{id:"self-attention-mechanism",children:"Self-Attention Mechanism"}),"\n",(0,i.jsx)(n.p,{children:"After obtaining the input encoding, we can move on to the core part of the Transformer model: the self-attention mechanism."}),"\n",(0,i.jsx)(n.p,{children:"Here, we need to prepare three transformation matrices:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Query Matrix ",(0,i.jsx)(n.code,{children:"W_q"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["First, declare a set of weights ",(0,i.jsx)(n.code,{children:"W_q"}),", then multiply the input embedding tensor by the Query matrix to get the Query tensor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"W_q = nn.Linear(512, 512)\nquery = W_q(embedded_input)\nprint(query.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Key Matrix ",(0,i.jsx)(n.code,{children:"W_k"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, declare a set of weights ",(0,i.jsx)(n.code,{children:"W_k"}),", then multiply the input embedding tensor by the Key matrix to get the Key tensor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"W_k = nn.Linear(512, 512)\nkey = W_k(embedded_input)\nprint(key.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Value Matrix ",(0,i.jsx)(n.code,{children:"W_v"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, declare a set of weights ",(0,i.jsx)(n.code,{children:"W_v"}),", then multiply the input embedding tensor by the Value matrix to get the Value tensor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"W_v = nn.Linear(512, 512)\nvalue = W_v(embedded_input)\nprint(value.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"So, what exactly is this QKV stuff?"}),"\n",(0,i.jsx)(n.p,{children:"You can think of the transformation matrices as projections."}),"\n",(0,i.jsx)(n.p,{children:'Projections mean "viewing from a different perspective."'}),"\n",(0,i.jsx)(n.p,{children:"The QKV process involves three different projections of the input, followed by the self-attention mechanism calculations."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"The second step of the self-attention mechanism is to calculate the attention scores."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Self-Attention Mechanism",src:t(72675).A+"",width:"1092",height:"200"})}),"\n",(0,i.jsx)(n.p,{children:"In this step, we perform a dot product between the Query tensor and the Key tensor."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_maps = torch.matmul(query, key.transpose(-2, -1))\nprint(attn_maps.shape)\n# >>> torch.Size([1, 4, 4])\n"})}),"\n",(0,i.jsx)(n.p,{children:"This gives us an attention score matrix of size 4x4."}),"\n",(0,i.jsx)(n.p,{children:"In this example, it explores the relationships between [\u4f60, \u597d, \u554a, \u3002] (you, good, ah, .)."}),"\n",(0,i.jsxs)(n.p,{children:["In the formula, you'll see ",(0,i.jsx)(n.code,{children:"1/sqrt(d_k)"}),", which scales the attention scores to prevent them from becoming too large or too small."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_maps = attn_maps / math.sqrt(512)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next is the Softmax operation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_maps = F.softmax(attn_maps, dim=-1)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why use Softmax? Why not Sigmoid?"})}),(0,i.jsx)(n.p,{children:"The Softmax function converts all attention scores into a probability distribution, ensuring the total attention score sums to 1. This allows better weighting of"}),(0,i.jsx)(n.p,{children:"each position. Additionally, the Softmax function has a competition mechanism, enabling the model to differentiate between positions more effectively."})]}),"\n",(0,i.jsx)(n.p,{children:"After calculating the attention map, we can perform a weighted sum of the Value tensor:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_output = torch.matmul(attn_maps, value)\nprint(attn_output.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, apply residual connections:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_output = embedded_input + attn_output\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multi-head-attention-mechanism",children:"Multi-Head Attention Mechanism"}),"\n",(0,i.jsx)(n.p,{children:'After understanding the above section, your next question might be: "What if we want multiple attention scores instead of just one for each position?"'}),"\n",(0,i.jsxs)(n.p,{children:["The authors also thought of this, so they proposed the ",(0,i.jsx)(n.strong,{children:"multi-head attention mechanism"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In the multi-head attention mechanism, we prepare multiple sets of QKV matrices and perform self-attention calculations for each set."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Multi-Head Attention Mechanism",src:t(82566).A+"",width:"1224",height:"668"})}),"\n",(0,i.jsx)(n.p,{children:"Although the concept is to have multiple heads, in practice, we do not prepare multiple sets of QKV matrices. Instead, we split the original QKV matrices into multiple sub-matrices and perform self-attention calculations on each sub-matrix, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Split into multiple heads\nQ = Q.view(Q.size(0), Q.size(1), self.num_heads, self.head_dim).transpose(1, 2)\nK = K.view(K.size(0), K.size(1), self.num_heads, self.head_dim).transpose(1, 2)\nV = V.view(V.size(0), V.size(1), self.num_heads, self.head_dim).transpose(1, 2)\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, this is too engineering-focused and does not introduce new concepts, so we will not delve deeper here."}),"\n",(0,i.jsx)(n.h3,{id:"cross-attention-mechanism",children:"Cross-Attention Mechanism"}),"\n",(0,i.jsx)(n.p,{children:"In the Transformer architecture, the attention mechanisms in the Encoder and Decoder are similar but have some differences."}),"\n",(0,i.jsxs)(n.p,{children:["In the Encoder, we perform self-attention calculations for each position in the sequence; in the Decoder, besides self-attention calculations for each position, we also need to perform attention calculations on the Encoder's output, which is known as ",(0,i.jsx)(n.strong,{children:"cross-attention"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The Decoder consists of two parts: the first part performs self-attention on its own sequence, and the second part performs cross-attention on the Encoder's output. We have covered self-attention; now let's discuss cross-attention calculations."}),"\n",(0,i.jsx)(n.p,{children:"Again, we need to prepare three transformation matrices:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Query Matrix ",(0,i.jsx)(n.code,{children:"W_q"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["First, declare a set of weights ",(0,i.jsx)(n.code,{children:"W_q"}),", multiply the Decoder's input embedding tensor by the Query matrix to get the Query tensor. The length of ",(0,i.jsx)(n.code,{children:"decoder_input"})," can be different from ",(0,i.jsx)(n.code,{children:"encoder_output"}),". If we encounter a translation problem, this length might be 10."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"W_q = nn.Linear(512, 512)\ndecoder_query = W_q(decoder_input)\nprint(decoder_query.shape)\n# >>> torch.Size([1, 10, 512])\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Here, the input is ",(0,i.jsx)(n.code,{children:"decoder_input"}),"."]})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Key Matrix ",(0,i.jsx)(n.code,{children:"W_k"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, declare a set of weights ",(0,i.jsx)(n.code,{children:"W_k"}),", multiply the Encoder's output embedding tensor by the Key matrix to get the Key tensor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"W_k = nn.Linear(512, 512)\nencoder_key = W_k(encoder_output)\nprint(encoder_key.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Here, the input is ",(0,i.jsx)(n.code,{children:"encoder_input"}),"."]})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Value Matrix ",(0,i.jsx)(n.code,{children:"W_v"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Finally, declare a set of weights ",(0,i.jsx)(n.code,{children:"W_v"}),", multiply the Encoder's output embedding tensor by the Value matrix to get the Value tensor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"W_v = nn.Linear(512, 512)\nencoder_value = W_v(encoder_output)\nprint(encoder_value.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Here, the input is ",(0,i.jsx)(n.code,{children:"encoder_input"}),"."]})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The subsequent steps are the same as the self-attention mechanism: first, calculate the attention map:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_maps = torch.matmul(decoder_query, encoder_key.transpose(-2, -1))\nprint(attn_maps.shape)\n# >>> torch.Size([1, 10, 4])\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then, perform scaling and Softmax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_maps = attn_maps / math.sqrt(512)\nattn_maps = F.softmax(attn_maps, dim=-1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finally, perform a weighted sum of the Value tensor:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"attn_output = torch.matmul(attn_maps, encoder_value)\nprint(attn_maps.shape)\n# >>> torch.Size([1, 10, 4])\nprint(encoder_value.shape)\n# >>> torch.Size([1, 4, 512])\nprint(attn_output.shape)\n# >>> torch.Size([1, 10, 512])\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"In the self-attention phase of the Decoder, a mask operation is typically added to ensure that during decoding, future information cannot be seen. This mask is usually an upper triangular matrix, ensuring that the Decoder can only see the generated part during decoding."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def _generate_square_subsequent_mask(\n    sz: int,\n    device: torch.device = torch.device(torch._C._get_default_device()),  # torch.device('cpu'),\n    dtype: torch.dtype = torch.get_default_dtype(),\n) -> Tensor:\n    r\"\"\"Generate a square causal mask for the sequence.\n\n    The masked positions are filled with float('-inf'). Unmasked positions are filled with float(0.0).\n    \"\"\"\n    return torch.triu(\n        torch.full((sz, sz), float('-inf'), dtype=dtype, device=device),\n        diagonal=1,\n    )\n"})})]}),"\n",(0,i.jsx)(n.h3,{id:"feed-forward-network",children:"Feed-Forward Network"}),"\n",(0,i.jsx)(n.p,{children:"After the self-attention mechanism, we need to pass through a simple feed-forward network to extract features."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ffn = nn.Sequential(\n    nn.Linear(512, 2048),\n    nn.ReLU(),\n    nn.Linear(2048, 512)\n)\nffn_output = ffn(attn_output)\noutput = attn_output + ffn_output\nprint(output.shape)\n# >>> torch.Size([1, 4, 512])\n"})}),"\n",(0,i.jsx)(n.p,{children:"This feed-forward network is a typical fully connected network. Here, we use two fully connected layers with a ReLU activation function in between."}),"\n",(0,i.jsx)(n.p,{children:"Additionally, there is an expand-dim operation in the module, usually with an expansion factor of 4. This operation is similar to the concept of the Inverted Residual Bottleneck Block proposed in MobileNet-V2. The main purpose is to improve the model's nonlinear representation ability by expanding the dimensions and then compressing them."}),"\n",(0,i.jsx)(n.h3,{id:"layer-normalization",children:"Layer Normalization"}),"\n",(0,i.jsxs)(n.p,{children:["We haven't mentioned ",(0,i.jsx)(n.code,{children:"LayerNorm"})," yet."]}),"\n",(0,i.jsx)(n.p,{children:"This operation is straightforward. After understanding all the steps above, it just takes a few lines of code."}),"\n",(0,i.jsxs)(n.p,{children:["In each step, we should apply ",(0,i.jsx)(n.code,{children:"LayerNorm"})," to each output. There are two types: Norm-First and Norm-Last, depending on your model architecture. We will discuss this in more detail in other papers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"norm1 = nn.LayerNorm(512)\nattn_output = norm1(embedded_input + attn_output)\n\n# ...\n\nnorm2 = nn.LayerNorm(512)\noutput = norm2(attn_output + ffn_output)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why not use Batch Normalization?"})}),(0,i.jsxs)(n.p,{children:["Sequence data relies more on its characteristics than those of batch data. Therefore, ",(0,i.jsx)(n.code,{children:"LayerNorm"})," is more suitable than ",(0,i.jsx)(n.code,{children:"BatchNorm"})," in this context."]})]}),"\n",(0,i.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,i.jsx)(n.h3,{id:"why-use-self-attention",children:"Why Use Self-Attention?"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Attention",src:t(14769).A+"",width:"1224",height:"400"})}),"\n",(0,i.jsx)(n.p,{children:"In short, it's fast."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"The authors summarized the computational complexity of RNN, CNN, and Self-Attention, as shown in the figure above."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Self-Attention Layer (Unrestricted):"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Per Layer Complexity: O(n^2\xb7d)"}),": In the self-attention mechanism, each input token (sequence length n) needs to attend to every other token, forming an (n * n) attention matrix. Each matrix element requires calculations based on the embedding dimension (d), resulting in a total complexity of O(n^2\xb7d)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sequential Operations: O(1)"}),": The full attention matrix can be computed in parallel, allowing all comparisons to occur simultaneously."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maximum Path Length: O(1)"}),": Since each token can directly attend to any other token, the maximum path length is just one step."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"RNN:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Per Layer Complexity: O(n\xb7d^2)"}),": RNN layers process each token sequentially. Each token's calculation combines the current token embedding (d-dimension) and the hidden state (also d-dimension), resulting in an operation cost of O(d^2). Since n tokens are processed, the total complexity is O(n\xb7d^2)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sequential Operations: O(n)"}),": Due to RNN's sequential nature, each token must wait for the previous token's calculation to complete before processing the next."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maximum Path Length: O(n)"}),": In RNNs, the path length between two tokens requires traversing through all intermediate tokens between them."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CNN:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Per Layer Complexity: O(k\xb7n\xb7d^2)"}),": In convolutional layers, a kernel of width k slides over the sequence to compute local features. Each n tokens need computations in the d-dimensional embeddings, and each convolution operation costs O(d^2). Thus, the total complexity is O(k\xb7n\xb7d^2)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sequential Operations: O(1)"}),": Each convolution filter can be applied to the entire sequence simultaneously."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maximum Path Length: O(log_k(n))"}),": By stacking convolutional layers with dilation, the network can connect distant tokens logarithmically to k."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Restricted Self-Attention Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Per Layer Complexity: O(r\xb7n\xb7d)"}),": Here, each token can only attend to a neighborhood of size r. The attention matrix becomes (n\xb7r), but each element still requires calculations based on the embedding dimension (d), resulting in a total complexity of O(r\xb7n\xb7d)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sequential Operations: O(1)"}),": Similar to unrestricted self-attention, all comparisons can be performed simultaneously."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maximum Path Length: O(n/r)"}),": Since each token can only attend to a smaller neighborhood, the path length between two distant tokens increases to O(n/r)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"experimental-results-machine-translation",children:"Experimental Results: Machine Translation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Machine Translation Results",src:t(42964).A+"",width:"1224",height:"564"})}),"\n",(0,i.jsx)(n.p,{children:"In the WMT 2014 English-German translation task, the Transformer (big) improved the BLEU score by over 2.0 points compared to the previous best models (including ensemble models), setting a new record of 28.4 BLEU. This model trained for 3.5 days using 8 P100 GPUs. Even the base model surpassed all previously published models and ensemble models at a significantly lower training cost."}),"\n",(0,i.jsx)(n.p,{children:"In the WMT 2014 English-French translation task, the Transformer (big) achieved a BLEU score of 41.0, outperforming all previously published single models at a quarter of the training cost."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The Transformer is a groundbreaking architecture that not only addresses some of the issues of RNN and LSTM models but also improves training and inference efficiency."}),"\n",(0,i.jsx)(n.p,{children:"When first introduced, the Transformer architecture did not make a significant impact."}),"\n",(0,i.jsx)(n.p,{children:"While the Transformer was widely and continuously discussed in academic circles for several years, from natural language processing to computer vision, it might have only attracted the attention of engineers and researchers in the industry."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},29538:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img1-2fb089a5c6c4d595f9fca68049e2231f.jpg"},98765:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img2-cbe3382cb0317923940c18f68c30396a.jpg"},53872:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img3-033caff830afdc9ee3b7c37bff128b69.jpg"},72675:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img4-e327434cd6cf917afa84de0cd0782f82.jpg"},82566:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img5-6d96f0be8d115cecfdd7d74da29ce155.jpg"},14769:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img6-704528b56ee6c919f91f628dacf509df.jpg"},42964:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/img7-b159f5ad9d164a16131418d0142b8972.jpg"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);