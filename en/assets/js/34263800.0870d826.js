"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9323],{52362:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=t(74848),s=t(28453);const r={},a="[19.12] UNet++",o={id:"feature-fusion/unetpp/index",title:"[19.12] UNet++",description:"The Subtle Weaver",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/feature-fusion/1912-unetpp/index.md",sourceDirName:"feature-fusion/1912-unetpp",slug:"/feature-fusion/unetpp/",permalink:"/en/papers/feature-fusion/unetpp/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1723708841e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[19.11] EfficientDet",permalink:"/en/papers/feature-fusion/bifpn/"},next:{title:"Language Model",permalink:"/en/papers/category/language-model"}},l={},c=[{value:"The Subtle Weaver",id:"the-subtle-weaver",level:2},{value:"Problem Definition",id:"problem-definition",level:2},{value:"Solution",id:"solution",level:2},{value:"UNet++ Model Design",id:"unet-model-design",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Is It Just About More Parameters?",id:"is-it-just-about-more-parameters",level:3},{value:"Deep Supervision and Model Pruning",id:"deep-supervision-and-model-pruning",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"1912-unet",children:"[19.12] UNet++"}),"\n",(0,i.jsx)(n.h2,{id:"the-subtle-weaver",children:"The Subtle Weaver"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/1912.05074",children:"UNet++: Redesigning Skip Connections to Exploit Multiscale Features in Image Segmentation"})})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"The authors of this paper use U-Net as a starting point to explore design issues in the original U-Net architecture."}),"\n",(0,i.jsx)(n.p,{children:"To quote the authors:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:'"Is there really nothing wrong with this topology that hasn\'t changed in three years?"'}),"\n",(0,i.jsxs)(n.p,{children:["Excerpted from ",(0,i.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/44958351",children:(0,i.jsx)(n.strong,{children:"\u7814\u4e60 U-Net"})})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The authors believe that U-Net not only has issues but also has many."}),"\n",(0,i.jsx)(n.h2,{id:"problem-definition",children:"Problem Definition"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"UNetpp_1",src:t(98083).A+"",width:"1024",height:"204"})}),"\n",(0,i.jsx)(n.p,{children:"The common U-Net has a depth of five down-sampling layers, as shown in diagram (d) above."}),"\n",(0,i.jsx)(n.p,{children:"Why not three layers? Why not seven layers? How deep should the network be designed?"}),"\n",(0,i.jsx)(n.p,{children:"In many deep learning applications, the depth of the network is often a critical parameter that directly impacts the performance and learning capability of the network."}),"\n",(0,i.jsx)(n.p,{children:"Let's delve into various aspects of this question:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Feature Representation Capability"})}),"\n",(0,i.jsx)(n.p,{children:"The depth of the network determines its representation capability. Simply put, deeper networks can usually learn more complex and abstract features. In tasks such as image segmentation, object detection, or classification, this ability to capture abstract features can be crucial. Shallower networks might only capture simpler, more local features."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Computational Complexity"})}),"\n",(0,i.jsx)(n.p,{children:"As the network depth increases, the computational complexity and the number of parameters usually grow dramatically. This not only increases training and inference time costs but also demands more computational resources. Finding an appropriate network depth is challenging when resources are limited."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Overfitting and Generalization"})}),"\n",(0,i.jsx)(n.p,{children:"Deeper networks usually have higher model complexity and might be prone to overfitting, especially with smaller datasets. Shallower networks might generalize better but could sacrifice some representation capability."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Optimization Difficulty"})}),"\n",(0,i.jsx)(n.p,{children:"You could certainly down-sample 100 layers (if your image is large enough), but as the network depth increases, optimizing the network parameters becomes increasingly difficult. Issues such as vanishing or exploding gradients might occur, requiring specific initialization methods or optimizers to address."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Theory vs. Practice"})}),"\n",(0,i.jsx)(n.p,{children:"Theoretically, deep networks can represent the same functions with fewer nodes and computations, but in practice, finding an appropriate network depth is not straightforward. Both overly deep and overly shallow networks might not perform well on specific tasks."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Dataset and Task Characteristics"})}),"\n",(0,i.jsx)(n.p,{children:"Different datasets and tasks might require different network depths. Some tasks might need deep networks to capture complex patterns, while others might not require as many abstract layers."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Interpretability and Debugging Difficulty"})}),"\n",(0,i.jsx)(n.p,{children:"As the network gets deeper, model interpretability might decrease, making it harder to debug and understand the model's behavior."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'By thoroughly investigating the question of "how deep," we can better understand how network depth impacts the performance and effectiveness of deep learning models, and how to make reasonable choices and designs in practical applications.'}),"\n",(0,i.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,i.jsx)(n.h3,{id:"unet-model-design",children:"UNet++ Model Design"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"UNetpp_2",src:t(96276).A+"",width:"1024",height:"244"})}),"\n",(0,i.jsx)(n.p,{children:"When addressing image segmentation and similar problems, the ideal scenario is for the network to effectively learn features at different depths to better understand and process image data."}),"\n",(0,i.jsx)(n.p,{children:"In exploring this issue, the authors proposed several innovative network structure designs aimed at better integrating features at different depths and optimizing network performance."}),"\n",(0,i.jsx)(n.p,{children:"Here are the core design concepts and schemes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Unified Architecture (U-Nete)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Objective:"})," Define a unified architecture for nested U-Nets"]}),"\n",(0,i.jsx)(n.li,{children:"This design integrates U-Nets of different depths into a single unified architecture. In this architecture, all U-Nets share at least part of the encoder while having their own decoders. This design allows decoders of different depths to operate independently within the same network structure, providing a unique perspective to observe and compare how different depths affect network performance."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Upgraded U-Net (UNet+)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Objective:"})," Serve as a control group to verify the effectiveness of long connections"]}),"\n",(0,i.jsx)(n.li,{children:"This design evolved from U-Nete, discarding the original long skip connections in favor of short skip connections linking every two adjacent nodes. This design enables deeper decoders to send supervision signals to shallower decoders, achieving better information transmission and feature integration. It aims to explore how collaboration between decoders of different depths impacts overall network performance."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Advanced U-Net (UNet++)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Objective:"})," Experimental group to verify the effectiveness of long connections"]}),"\n",(0,i.jsx)(n.li,{children:"Built on the foundation of U-Nete, UNet++ achieves dense connected skip connections by linking decoders. This design allows dense feature propagation along the skip connections, achieving more flexible feature fusion. UNet++ aims to realize more flexible and efficient feature extraction and fusion within a unified architecture to tackle challenges posed by different depths."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Through these architectural designs, the authors aim to retain the advantages of the original U-Net architecture while addressing the issue of network depth selection, integrating features from different depths to improve performance in tasks such as image segmentation."}),"\n",(0,i.jsx)(n.p,{children:"Of course, this architectural design didn't materialize out of nowhere. It evolved through the authors' thought process and changes, which you can explore further in their detailed writings."}),"\n",(0,i.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,i.jsx)(n.p,{children:"Let's discuss several questions based on the above content:"}),"\n",(0,i.jsx)(n.h3,{id:"is-it-just-about-more-parameters",children:"Is It Just About More Parameters?"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"UNetpp_3",src:t(74801).A+"",width:"1024",height:"283"})}),"\n",(0,i.jsx)(n.p,{children:"To address this doubt, the authors designed an experiment where they scaled up the original U-Net to match the parameter count of UNet++ and compared the results. Although this approach might be considered a bit crude (according to the authors), the table shows that simply increasing the number of parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Doesn't result in any significant improvement."})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In deep learning, more parameters usually imply higher representational capacity for the model, but this doesn't always lead to better results. Too many parameters might lead to overfitting, especially with smaller datasets. Moreover, as the number of parameters increases, the computation and storage requirements also rise significantly, which might not be desirable. UNet++ demonstrates the importance of optimizing network structure rather than merely adding more parameters."}),"\n",(0,i.jsx)(n.h3,{id:"deep-supervision-and-model-pruning",children:"Deep Supervision and Model Pruning"}),"\n",(0,i.jsx)(n.p,{children:"When exploring network structures in deep learning, especially for image segmentation tasks using the U-Net architecture, two concepts stand out: Deep Supervision and Model Pruning. These techniques not only enhance the learning efficiency of the network but also help significantly reduce the model's size while maintaining a certain level of accuracy, thereby accelerating the inference process, particularly in resource-constrained environments like mobile devices."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deep Supervision"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"UNetpp_4",src:t(78242).A+"",width:"740",height:"526"})}),"\n",(0,i.jsx)(n.p,{children:"The core idea of deep supervision is to introduce additional loss functions at different stages of the network to ensure effective gradient updates even in shallower network structures. By adding auxiliary losses in each level of the sub-networks, every stage of the U-Net can receive clear supervisory signals, thereby promoting the overall network's learning. In the UNet++ architecture, deeper supervision allows each sub-network's output to be regarded as the segmentation result, providing a natural and direct solution to overcome the issue of vanishing gradients."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Model Pruning"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"UNetpp_5",src:t(98239).A+"",width:"1024",height:"181"})}),"\n",(0,i.jsx)(n.p,{children:"Model pruning is another effective technique for reducing model size. By evaluating the performance of each sub-network on a validation set, it is possible to determine how much of the redundant network structure can be pruned without losing accuracy. During the inference phase, appropriate network depth can be selected based on actual requirements to balance performance and computational costs."}),"\n",(0,i.jsx)(n.p,{children:"After discussing the concepts of the UNet++ structure and model pruning, we can analyze its feasibility and importance from the following aspects:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Feasibility"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Deep Supervision and Multi-Output: The UNet++ structure, through deep supervision, possesses multi-level outputs, allowing each sub-network to generate image segmentation results. Due to this design, the performance of each sub-network can be independently evaluated, providing a foundation for subsequent pruning."}),"\n",(0,i.jsx)(n.li,{children:"Model Pruning: During the testing phase, forward propagation is sufficient, and if certain sub-networks can already produce satisfactory results, pruning other sub-networks won't affect the output of the preceding sub-networks. However, during training, the pruned parts contribute to weight updates during backpropagation, indicating their importance in the training process. This design ensures the feasibility of pruning while maintaining network performance."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Importance"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Computational Efficiency and Resource Utilization: Through pruning, the model size is significantly reduced. For example, if the output of the L2 layer is satisfactory, many parameters can be pruned, greatly reducing computational and storage demands. This is particularly important for running models in resource-constrained environments, such as mobile devices."}),"\n",(0,i.jsx)(n.li,{children:"Speedup: The pruned network structure can significantly improve inference speed. For instance, replacing L4 with L2 can triple the processing speed, which is crucial for applications requiring real-time or near-real-time responses."}),"\n",(0,i.jsx)(n.li,{children:"Flexible Network Structure: Through reasonable pruning, UNet++ offers a flexible network structure that can be adjusted based on the task requirements and dataset difficulty to achieve a good balance between performance and efficiency."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Balancing Accuracy and Model Size"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The relationship between dataset difficulty and network depth suggests that through pruning, smaller models can be used for simpler datasets while maintaining similar performance. This design allows UNet++ to reduce model size and computational costs while maintaining high accuracy."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the implementation of the UNet++ architecture, the successful application of deep supervision and model pruning has significantly reduced the number of parameters while maintaining good segmentation performance. This not only improves the model's running efficiency on mobile devices but also offers new insights into network design flexibility and adjustability."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Implementing deep supervision and model pruning on UNet++ demonstrates the potential of these methods in optimizing image segmentation tasks."}),"\n",(0,i.jsx)(n.p,{children:"Deep supervision allows the model to obtain better feature representation at different network levels, while pruning provides an effective way to reduce computational and storage needs while maintaining performance, especially important for resource-constrained environments."}),"\n",(0,i.jsx)(n.p,{children:"However, from an engineering perspective, these methods also present challenges:"}),"\n",(0,i.jsx)(n.p,{children:"Most intuitively, determining the extent of pruning depends on performance on the validation set, which may lead to performance instability across different datasets or real-world applications, possibly causing the model to fail unexpectedly."}),"\n",(0,i.jsx)(n.p,{children:"One possible direction to address this issue is to adopt adaptive pruning strategies, dynamically adjusting the pruning extent at different stages and exploring multi-objective optimization methods to balance accuracy and efficiency. Alternatively, using cross-dataset validation and transfer learning techniques could improve the model's generalization ability and stability in different application scenarios."}),"\n",(0,i.jsx)(n.p,{children:"In practice, implementing deep supervision and model pruning increases the complexity of model design and training. Engineers might need to invest additional time and resources to adjust and validate pruning strategies to ensure the model's generalization ability, potentially extending the development cycle."}),"\n",(0,i.jsx)(n.p,{children:"This paper offers new insights into optimizing feature fusion methods but still presents certain technical challenges that need to be overcome through further research and practice. It is hoped that this article provides valuable reference and inspiration for researchers' work and research."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},98083:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/unetpp_1-25be1ac5d2f0c8250257166a10c85fd7.jpg"},96276:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/unetpp_2-316f3fd4393960b0bc97b5a98765cbfe.jpg"},74801:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/unetpp_3-e7076be2db82c82591e4efb4ffe59a56.jpg"},78242:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/unetpp_4-89eabd8ec640fdfa657b8b214f6eaa5c.jpg"},98239:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/unetpp_5-47f073a8eec6816a9ad912c6303d6f17.jpg"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);