"use strict";(self.webpackChunkdocsaid_website=self.webpackChunkdocsaid_website||[]).push([["32238"],{32216:function(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>a,toc:()=>l});var a=i(93610),t=i(85893),s=i(50065);let d={slug:"pydantic-intro",title:"Pydantic Introduction: Python Data Validation and Management",authors:"Z. Yuan",image:"/en/img/2025/0317.webp",tags:["Python","Pydantic","Data Validation"],description:"A simple introduction to the basic concepts of Pydantic."},r=void 0,o={authorsImageUrls:[void 0]},l=[{value:"What is Pydantic?",id:"what-is-pydantic",level:2},{value:"Basic Usage and Common Features",id:"basic-usage-and-common-features",level:2},{value:"1. Creating Data Models",id:"1-creating-data-models",level:3},{value:"2. Automatic Validation",id:"2-automatic-validation",level:3},{value:"3. Automatic Type Conversion and Default Values",id:"3-automatic-type-conversion-and-default-values",level:3},{value:"4. Nested Models",id:"4-nested-models",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"1. Custom Validators",id:"1-custom-validators",level:3},{value:"2. Cross-field Validation",id:"2-cross-field-validation",level:3},{value:"Using Pydantic with FastAPI",id:"using-pydantic-with-fastapi",level:2},{value:"And More",id:"and-more",level:2},{value:"1. Generic Models",id:"1-generic-models",level:3},{value:"2. Asynchronous Processing",id:"2-asynchronous-processing",level:3},{value:"3. Schema Definition",id:"3-schema-definition",level:3},{value:"4. ORM Integration",id:"4-orm-integration",level:3},{value:"Comparison with <code>dataclass</code>",id:"comparison-with-dataclass",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"I recently used this tool while working on the backend, so I thought I should document it."}),"\n",(0,t.jsx)(n.h2,{id:"what-is-pydantic",children:"What is Pydantic?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://docs.pydantic.dev",children:"Pydantic"})," is a validation tool written in Python, designed to handle various messy data issues and also help manage configuration files that often gather dust in the corner. It's particularly suitable for engineers because it solves many problems:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Validation"}),": Helps you filter out various incorrect data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Conversion"}),": Easily converts the weird data from the front-end (e.g., ",(0,t.jsx)(n.code,{children:'"123"'}),") into the desired ",(0,t.jsx)(n.code,{children:"int"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Defining Data Models"}),": You can write structured code without randomly inserting Dicts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enhancing API Security and Readability"}),": It just looks good."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Seamless Integration with FastAPI"}),": It's tightly integrated with FastAPI, saving you from writing hundreds of lines of code."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Installation is straightforward:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"pip install pydantic\n"})}),"\n",(0,t.jsx)(n.h2,{id:"basic-usage-and-common-features",children:"Basic Usage and Common Features"}),"\n",(0,t.jsx)(n.h3,{id:"1-creating-data-models",children:"1. Creating Data Models"}),"\n",(0,t.jsxs)(n.p,{children:["Define a structured data model using ",(0,t.jsx)(n.code,{children:"BaseModel"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-automatic-validation",children:"2. Automatic Validation"}),"\n",(0,t.jsxs)(n.p,{children:["When creating a ",(0,t.jsx)(n.code,{children:"User"})," object, Pydantic automatically validates the data and converts types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user = User(id=1, name='Alice', email='alice@example.com')\nprint(user)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the data type does not match, it raises a ",(0,t.jsx)(n.code,{children:"ValidationError"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"try:\n    user = User(id='abc', name='Alice', email='alice@example.com')\nexcept Exception as e:\n    print(e)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-automatic-type-conversion-and-default-values",children:"3. Automatic Type Conversion and Default Values"}),"\n",(0,t.jsx)(n.p,{children:"Example of automatic type conversion:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user = User(id='123', name='Bob', email='bob@example.com')\nprint(user.id)  # Outputs 123 (int)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example of default values and optional fields:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from typing import Optional\n\nclass User(BaseModel):\n    id: int\n    name: str = 'Unknown'\n    is_active: bool = True\n    nickname: Optional[str] = None\n\nuser = User(id=10)\nprint(user.name)      # Unknown\nprint(user.is_active) # True\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-nested-models",children:"4. Nested Models"}),"\n",(0,t.jsxs)(n.p,{children:["When defining nested models, Pydantic can automatically parse a ",(0,t.jsx)(n.code,{children:"dict"})," into the corresponding object:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class Address(BaseModel):\n    city: str\n    zipcode: str\n\nclass User(BaseModel):\n    id: int\n    name: str\n    address: Address\n\nuser = User(id=1, name="Alice", address={"city": "Taipei", "zipcode": "100"})\nprint(user.address.city)  # Outputs "Taipei"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,t.jsx)(n.h3,{id:"1-custom-validators",children:"1. Custom Validators"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"validator"})," to define custom validation logic for fields:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pydantic import validator\n\nclass User(BaseModel):\n    id: int\n    email: str\n\n    @validator('email')\n    def email_must_contain_at(cls, v):\n        if '@' not in v:\n            raise ValueError('Invalid email')\n        return v\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-cross-field-validation",children:"2. Cross-field Validation"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"root_validator"})," to perform cross-field validation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pydantic import root_validator\n\nclass User(BaseModel):\n    password1: str\n    password2: str\n\n    @root_validator\n    def passwords_match(cls, values):\n        if values.get('password1') != values.get('password2'):\n            raise ValueError('Passwords do not match')\n        return values\n"})}),"\n",(0,t.jsx)(n.h2,{id:"using-pydantic-with-fastapi",children:"Using Pydantic with FastAPI"}),"\n",(0,t.jsx)(n.p,{children:"Combine FastAPI with Pydantic to define data models:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    price: float\n\n@app.post("/items/")\nasync def create_item(item: Item):\n    return {"item": item.dict()}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"and-more",children:"And More"}),"\n",(0,t.jsx)(n.p,{children:"Here are some less common but powerful uses:"}),"\n",(0,t.jsx)(n.h3,{id:"1-generic-models",children:"1. Generic Models"}),"\n",(0,t.jsx)(n.p,{children:"When you want an API response that includes both generic messages (like status or error messages), you can use it this way:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from typing import TypeVar, Generic\nfrom pydantic import BaseModel\n\nT = TypeVar("T")\n\nclass ResponseModel(BaseModel, Generic[T]):\n    data: T\n    message: str\n'})}),"\n",(0,t.jsxs)(n.p,{children:["By using ",(0,t.jsx)(n.code,{children:"TypeVar"}),", you define a type variable ",(0,t.jsx)(n.code,{children:"T"})," that can be replaced with any type. This allows ",(0,t.jsx)(n.code,{children:"ResponseModel"})," to inherit from both ",(0,t.jsx)(n.code,{children:"BaseModel"})," and ",(0,t.jsx)(n.code,{children:"Generic[T]"}),", making it accept different types of ",(0,t.jsx)(n.code,{children:"data"})," as needed. This kind of generic model greatly enhances reusability and flexibility."]}),"\n",(0,t.jsx)(n.h3,{id:"2-asynchronous-processing",children:"2. Asynchronous Processing"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"parse_obj_as"})," for asynchronous data parsing, which allows you to convert raw data structures (like lists or dictionaries) into specified Pydantic models, suitable for handling large amounts of data asynchronously."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pydantic import parse_obj_as\nfrom typing import List\n\nusers = parse_obj_as(List[User], [{"id": 1, "name": "Alice", "email": "alice@example.com"}])\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Although ",(0,t.jsx)(n.code,{children:"parse_obj_as"})," itself is not an async function, it can be used in asynchronous environments to quickly parse and validate data fetched from databases or APIs. This ensures that the incoming data conforms to the defined structure and type, improving program robustness and data processing efficiency."]}),"\n",(0,t.jsx)(n.h3,{id:"3-schema-definition",children:"3. Schema Definition"}),"\n",(0,t.jsxs)(n.p,{children:["Pydantic can automatically generate a JSON schema by calling the model's ",(0,t.jsx)(n.code,{children:"schema_json()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user_schema = User.schema_json()\nprint(user_schema)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This feature is very useful for generating API documentation, data validation, and integration with APIs. The generated schema can be included as part of API documentation, making it easier for front-end developers or third-party developers to reference."}),"\n",(0,t.jsx)(n.h3,{id:"4-orm-integration",children:"4. ORM Integration"}),"\n",(0,t.jsx)(n.p,{children:"Integrating Pydantic with SQLAlchemy allows you to bridge the gap between database models and API data models, enabling data validation and automatic conversion, simplifying the data handling process."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pydantic.orm import from_orm\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\nclass UserORM(Base):\n    __tablename__ = "users"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass UserSchema(BaseModel):\n    id: int\n    name: str\n\n    class Config:\n        orm_mode = True\n'})}),"\n",(0,t.jsxs)(n.p,{children:["First, define the ORM model (like ",(0,t.jsx)(n.code,{children:"UserORM"}),") in SQLAlchemy, describing the table structure. In the corresponding Pydantic model, set ",(0,t.jsx)(n.code,{children:"orm_mode = True"})," in the ",(0,t.jsx)(n.code,{children:"Config"})," class to allow the model to extract data from ORM objects and perform automatic conversion and validation. The ",(0,t.jsx)(n.code,{children:"from_orm"})," method makes it easy to convert ORM instances into Pydantic models, avoiding manual field mappings and improving data handling security and efficiency."]}),"\n",(0,t.jsx)(n.p,{children:"This integration method is particularly useful in web API development, where you need to return validated data from a database to the front-end, significantly simplifying the code and reducing errors."}),"\n",(0,t.jsxs)(n.h2,{id:"comparison-with-dataclass",children:["Comparison with ",(0,t.jsx)(n.code,{children:"dataclass"})]}),"\n",(0,t.jsxs)(n.p,{children:["Both Pydantic and Python's built-in ",(0,t.jsx)(n.code,{children:"dataclass"})," allow you to define structured data models, but there are clear differences in data validation and type conversion."]}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s a comparison table:"}),"\n",(0,t.jsx)("div",{style:{display:"flex",justifyContent:"center"},children:(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsxs)(n.th,{children:[(0,t.jsx)(n.code,{children:"dataclass"})," (built-in)"]}),(0,t.jsxs)(n.th,{children:[(0,t.jsx)(n.code,{children:"pydantic.BaseModel"})," (external library)"]})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Data Validation"})}),(0,t.jsx)(n.td,{children:"\u274C Not supported (manual check needed)"}),(0,t.jsx)(n.td,{children:"\u2705 Automatic validation (types and formats)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Type Conversion"})}),(0,t.jsx)(n.td,{children:"\u274C Not supported (manual handling)"}),(0,t.jsxs)(n.td,{children:["\u2705 Automatic conversion (e.g., ",(0,t.jsx)(n.code,{children:'"123"'})," \u2192 ",(0,t.jsx)(n.code,{children:"int"}),")"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Performance"})}),(0,t.jsx)(n.td,{children:"\u2B50\u2B50\u2B50\u2B50 (CPython native)"}),(0,t.jsx)(n.td,{children:"\u2B50\u2B50\u2B50 (v2 introduces Rust core optimizations)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"JSON Conversion"})}),(0,t.jsxs)(n.td,{children:["\u274C Requires manual ",(0,t.jsx)(n.code,{children:"json.dumps"})]}),(0,t.jsxs)(n.td,{children:["\u2705 Built-in ",(0,t.jsx)(n.code,{children:".json()"})," and ",(0,t.jsx)(n.code,{children:".dict()"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Nested Models"})}),(0,t.jsx)(n.td,{children:"\u274C Requires manual nesting"}),(0,t.jsx)(n.td,{children:"\u2705 Built-in support, automatic parsing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Optional Fields"})}),(0,t.jsxs)(n.td,{children:["\u274C Requires manual ",(0,t.jsx)(n.code,{children:"Optional"})]}),(0,t.jsx)(n.td,{children:"\u2705 Built-in support"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Environment Variable Reading"})}),(0,t.jsx)(n.td,{children:"\u274C Not supported"}),(0,t.jsxs)(n.td,{children:["\u2705 Supports ",(0,t.jsx)(n.code,{children:"BaseSettings"})," for ",(0,t.jsx)(n.code,{children:".env"})," reading"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Use Case"})}),(0,t.jsx)(n.td,{children:"Lightweight data storage"}),(0,t.jsx)(n.td,{children:"API validation, data parsing, and complex applications"})]})]})]})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"After going through the basics of Pydantic, doesn't the automatic validation and type conversion seem really useful?"}),"\n",(0,t.jsx)(n.p,{children:"A package that helps us write less code is definitely worth learning. Let\u2019s give it a try together!"})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},50065:function(e,n,i){i.d(n,{Z:()=>r,a:()=>d});var a=i(67294);let t={},s=a.createContext(t);function d(e){let n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),a.createElement(s.Provider,{value:n},e.children)}},93610:function(e){e.exports=JSON.parse('{"permalink":"/en/blog/pydantic-intro","source":"@site/i18n/en/docusaurus-plugin-content-blog/2025/03-17-pydantic-intro/index.md","title":"Pydantic Introduction: Python Data Validation and Management","description":"A simple introduction to the basic concepts of Pydantic.","date":"2025-03-17T00:00:00.000Z","tags":[{"inline":true,"label":"Python","permalink":"/en/blog/tags/python"},{"inline":true,"label":"Pydantic","permalink":"/en/blog/tags/pydantic"},{"inline":true,"label":"Data Validation","permalink":"/en/blog/tags/data-validation"}],"readingTime":5.25,"hasTruncateMarker":true,"authors":[{"name":"Z. Yuan","title":"Dosaid maintainer, Full-Stack AI Engineer","url":"https://github.com/zephyr-sh","socials":{"github":"https://github.com/zephyr-sh","linkedin":"https://www.linkedin.com/in/ze-yuan-sh7/"},"imageURL":"https://github.com/zephyr-sh.png","key":"Z. Yuan","page":null}],"frontMatter":{"slug":"pydantic-intro","title":"Pydantic Introduction: Python Data Validation and Management","authors":"Z. Yuan","image":"/en/img/2025/0317.webp","tags":["Python","Pydantic","Data Validation"],"description":"A simple introduction to the basic concepts of Pydantic."},"unlisted":false,"prevItem":{"title":"Write a Resume with JS!","permalink":"/en/blog/build-a-resume"},"nextItem":{"title":"I, an AI Engineer, Actually Built a Backend System?","permalink":"/en/blog/builds-dashboard-system"}}')}}]);