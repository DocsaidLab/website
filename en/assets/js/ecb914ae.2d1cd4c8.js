"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[729],{63636:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var i=r(74848),t=r(28453);const s={},a="[18.06] GPT-1",o={id:"transformers/gpt_1/index",title:"[18.06] GPT-1",description:"Twelve-Layer Decoder",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/transformers/1806-gpt_1/index.md",sourceDirName:"transformers/1806-gpt_1",slug:"/transformers/gpt_1/",permalink:"/en/papers/transformers/gpt_1/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1726488948e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[17.06] Transformer",permalink:"/en/papers/transformers/transformer/"},next:{title:"[18.10] BERT",permalink:"/en/papers/transformers/bert/"}},l={},d=[{value:"Twelve-Layer Decoder",id:"twelve-layer-decoder",level:2},{value:"Defining the Problem",id:"defining-the-problem",level:2},{value:"1. Lack of Labeled Data",id:"1-lack-of-labeled-data",level:3},{value:"2. Task Inconsistency",id:"2-task-inconsistency",level:3},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Model Architecture",id:"model-architecture",level:3},{value:"Pre-training Strategy",id:"pre-training-strategy",level:3},{value:"Fine-tuning Strategy",id:"fine-tuning-strategy",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Why is the Transformer Effective?",id:"why-is-the-transformer-effective",level:3},{value:"Which Part is Effective?",id:"which-part-is-effective",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"1806-gpt-1",children:"[18.06] GPT-1"})}),"\n",(0,i.jsx)(n.h2,{id:"twelve-layer-decoder",children:"Twelve-Layer Decoder"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf",children:(0,i.jsx)(n.strong,{children:"Improving Language Understanding by Generative Pre-Training"})})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"The original Transformer architecture consists of two parts: an encoder and a decoder. However, OpenAI took a different approach and chose to use a decoder-only architecture."}),"\n",(0,i.jsx)(n.h2,{id:"defining-the-problem",children:"Defining the Problem"}),"\n",(0,i.jsx)(n.p,{children:"The authors identified several issues with current NLP models:"}),"\n",(0,i.jsx)(n.h3,{id:"1-lack-of-labeled-data",children:"1. Lack of Labeled Data"}),"\n",(0,i.jsx)(n.p,{children:"In the field of NLP, while data is abundant, labeled data is scarce. This is particularly problematic when working on specific tasks such as specialized domain question answering (QA) or machine translation (MT), where the lack of corresponding labeled data makes training difficult."}),"\n",(0,i.jsx)(n.p,{children:'To address this, many methods adopt unsupervised learning, later known as self-supervised learning. A common approach is to use a "text completion" task, predicting the next word. This method requires no labeled data, only continuous collection of large amounts of text data for the model to learn from. However, this method introduces another issue: task inconsistency.'}),"\n",(0,i.jsx)(n.h3,{id:"2-task-inconsistency",children:"2. Task Inconsistency"}),"\n",(0,i.jsx)(n.p,{children:"In NLP models, there are typically two stages: pre-training and fine-tuning. Pre-training involves letting the model learn from large amounts of text data, while fine-tuning involves training the model further on specific tasks. The inconsistency between these two stages is problematic."}),"\n",(0,i.jsx)(n.p,{children:"In pre-training, the model learns to predict the next word, but in fine-tuning, the model might need to answer questions or translate sentences. Previous research has shown that introducing numerous parameters during fine-tuning improves model performance. Different tasks require different parameters, making the process cumbersome and difficult to manage."}),"\n",(0,i.jsx)(n.p,{children:"To address this, the authors proposed using a decoder-only architecture to adapt to different tasks with minimal parameter changes."}),"\n",(0,i.jsx)(n.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,i.jsx)(n.h3,{id:"model-architecture",children:"Model Architecture"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Model Architecture",src:r(79707).A+"",width:"1224",height:"620"})}),"\n",(0,i.jsx)(n.p,{children:"The proposed model architecture consists of 12 layers of decoders. The configuration is as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"12 decoder layers, each following the basic Transformer structure."}),"\n",(0,i.jsx)(n.li,{children:"Each decoder layer has 768 feature dimensions and 12 attention heads."}),"\n",(0,i.jsx)(n.li,{children:"The hidden layer in the feed-forward network (FFN) uses 3072 neurons."}),"\n",(0,i.jsx)(n.li,{children:"Sequence length is 512."}),"\n",(0,i.jsx)(n.li,{children:"Dropout rate is 0.1."}),"\n",(0,i.jsx)(n.li,{children:"L2 regularization is applied."}),"\n",(0,i.jsx)(n.li,{children:"Gelu activation function is used."}),"\n",(0,i.jsx)(n.li,{children:"Position encoding uses learnable positional embeddings."}),"\n",(0,i.jsxs)(n.li,{children:["Tokenization is done using the ",(0,i.jsx)(n.a,{href:"https://spacy.io/api/tokenizer",children:(0,i.jsx)(n.strong,{children:"spaCy tokenizer"})}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Training was conducted using:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Adam optimizer."}),"\n",(0,i.jsx)(n.li,{children:"Maximum learning rate of 2.5e-4, linearly increasing over the first 2000 steps, then using cosine annealing to 0."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pre-training-strategy",children:"Pre-training Strategy"}),"\n",(0,i.jsx)(n.p,{children:"Training the model involved two stages. The first stage was self-supervised learning on large text datasets, and the second stage was fine-tuning on target tasks. The datasets used were:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/1506.06724",children:(0,i.jsx)(n.strong,{children:"BooksCorpus"})}),":\nIt contains over 7,000 unique unpublished books covering various genres like adventure, fantasy, and romance. Importantly, it includes long stretches of contiguous text, allowing the model to learn long-range dependencies."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.statmt.org/lm-benchmark/",children:(0,i.jsx)(n.strong,{children:"1B Word Benchmark"})}),":\nSimilar to methods used by ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/1802.05365",children:"ELMo"}),", this dataset is roughly the same size but reorganized at the sentence level to disrupt long-range structure."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"fine-tuning-strategy",children:"Fine-tuning Strategy"}),"\n",(0,i.jsx)(n.p,{children:"The authors did not introduce any special techniques for fine-tuning but used standard methods. Unless otherwise specified, the hyperparameters from unsupervised pre-training were reused. A dropout rate of 0.1 was applied to the classifier, with a learning rate of 6.25e-5 and a batch size of 32 for most tasks."}),"\n",(0,i.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,i.jsx)(n.p,{children:"Overall, the proposed method achieved state-of-the-art (SoTA) results in 9 out of 12 evaluated datasets, demonstrating the effectiveness of the decoder-only architecture for NLP tasks. The authors conducted a deeper exploration into the topic of zero-shot learning."}),"\n",(0,i.jsx)(n.h3,{id:"why-is-the-transformer-effective",children:"Why is the Transformer Effective?"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Experimental Graph",src:r(53260).A+"",width:"1224",height:"652"})}),"\n",(0,i.jsx)(n.p,{children:"In Figure 2 (left), the authors explored how model performance improves with increased depth during task transfer. Results showed that each layer in the pre-trained model contains useful information for the target tasks."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"In Figure 2 (right), the authors visualized the model's effectiveness during pre-training, showing that performance improves as pre-training progresses. This indicates that pre-training generates features supportive of various tasks."}),"\n",(0,i.jsx)(n.h3,{id:"which-part-is-effective",children:"Which Part is Effective?"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Ablation Study",src:r(91305).A+"",width:"1514",height:"434"})}),"\n",(0,i.jsx)(n.p,{children:"To identify which components contributed most to the model's performance, the authors conducted three different ablation studies. Results are shown in Table 5 of the paper:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Impact of the Auxiliary Language Model Objective:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Removing the auxiliary language model objective during fine-tuning helped tasks like natural language inference (NLI) and question answering (QQP)."}),"\n",(0,i.jsx)(n.li,{children:"Larger datasets benefited more from the auxiliary objective, while smaller datasets did not show significant improvement."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Comparison Between Transformer and LSTM:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Comparing the Transformer with a single-layer LSTM with 2048 units showed that using LSTM resulted in an average performance drop of 5.6 points."}),"\n",(0,i.jsx)(n.li,{children:"LSTM outperformed the Transformer only on the MRPC dataset."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Importance of Pre-training:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Comparing a Transformer trained directly on the target task with a pre-trained Transformer showed that lack of pre-training significantly impacted performance, with a 14.8% drop in performance compared to the full model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"GPT-1 is OpenAI's first large-scale pre-trained model based on the Transformer architecture, marking a significant advancement in the field of natural language processing. By pre-training on large amounts of unlabelled text and fine-tuning on specific tasks, GPT-1 achieved remarkable performance improvements."}),"\n",(0,i.jsx)(n.p,{children:"The success of GPT-1 demonstrated the potential of the pre-training-fine-tuning paradigm in diverse NLP tasks, paving the way for the development of more powerful models like GPT-2 and GPT-3."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},79707:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/img1-87f8c6da47fd8cd40f20287200c28762.jpg"},53260:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/img2-67a61571b3bdb1f1a081e83cbbd7c645.jpg"},91305:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/img3-6587fb5a5e0a69bfd6a3beef2e91e114.jpg"},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var i=r(96540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);