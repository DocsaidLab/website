"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[187],{36975:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var i=s(74848),t=s(28453);const a={},r="[22.03] RepLKNet",l={id:"replknet/index",title:"[22.03] RepLKNet",description:"Giant Convolutional Kernels",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/2203-replknet/index.md",sourceDirName:"2203-replknet",slug:"/replknet/",permalink:"/en/papers/replknet/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1723089864e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[22.01] ConvNeXt",permalink:"/en/papers/convnext/"},next:{title:"[22.06] MobileOne",permalink:"/en/papers/mobileone/"}},o={},h=[{value:"Giant Convolutional Kernels",id:"giant-convolutional-kernels",level:2},{value:"Problem Definition",id:"problem-definition",level:2},{value:"A Guide to Using Large Kernels in Convolution",id:"a-guide-to-using-large-kernels-in-convolution",level:2},{value:"Deep Large Kernels Remain Efficient",id:"deep-large-kernels-remain-efficient",level:3},{value:"Large Kernels Heavily Rely on Residual Connections",id:"large-kernels-heavily-rely-on-residual-connections",level:3},{value:"Large Kernels Require Reparameterization",id:"large-kernels-require-reparameterization",level:3},{value:"Large Kernels Significantly Enhance Downstream Task Performance",id:"large-kernels-significantly-enhance-downstream-task-performance",level:3},{value:"Large Kernels Are Effective Even with Small Feature Maps",id:"large-kernels-are-effective-even-with-small-feature-maps",level:3},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Network Architecture",id:"network-architecture",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Evaluation of Large Kernels",id:"evaluation-of-large-kernels",level:3},{value:"Performance on ImageNet",id:"performance-on-imagenet",level:3},{value:"Large Kernel CNNs Have Larger ERF Than Deep Small Kernel Models",id:"large-kernel-cnns-have-larger-erf-than-deep-small-kernel-models",level:3},{value:"Shape Bias",id:"shape-bias",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",annotation:"annotation",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msqrt:"msqrt",ol:"ol",p:"p",path:"path",semantics:"semantics",span:"span",strong:"strong",svg:"svg",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"2203-replknet",children:"[22.03] RepLKNet"}),"\n",(0,i.jsx)(n.h2,{id:"giant-convolutional-kernels",children:"Giant Convolutional Kernels"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2203.06717",children:(0,i.jsx)(n.strong,{children:"Scaling Up Your Kernels to 31x31: Revisiting Large Kernel Design in CNNs"})})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The following content has been compiled by ChatGPT-4, with additional manual review and editing."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"In recent years, CNN architectures have faced challenges from ViT, causing their dominance to waver."}),"\n",(0,i.jsx)(n.p,{children:"Some argue that ViT's strength lies in its multi-head attention mechanism, which offers greater flexibility, reduced inductive bias, and robustness to distortions."}),"\n",(0,i.jsx)(n.p,{children:"However, another perspective attributes ViT's performance to its architecture, even when the multi-head attention is removed, resulting in similar performance."}),"\n",(0,i.jsx)(n.p,{children:"This paper differs by focusing on a single aspect: the design of large convolutional kernels."}),"\n",(0,i.jsx)(n.h2,{id:"problem-definition",children:"Problem Definition"}),"\n",(0,i.jsx)(n.p,{children:"Large kernel models have not been popular since VGG, except for some older models like Inceptions."}),"\n",(0,i.jsx)(n.p,{children:"VGG demonstrated that stacking small kernels can achieve the same receptive field, leading to a decline in interest in large kernel designs."}),"\n",(0,i.jsx)(n.p,{children:"Recent studies on large kernels have not addressed a key question:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Why do traditional CNNs underperform compared to ViTs? Is achieving a large receptive field crucial for closing the performance gap between CNNs and ViTs?"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"a-guide-to-using-large-kernels-in-convolution",children:"A Guide to Using Large Kernels in Convolution"}),"\n",(0,i.jsx)(n.p,{children:"To answer this question, the authors systematically explored the design of large kernels in CNNs and summarized five guidelines."}),"\n",(0,i.jsx)(n.h3,{id:"deep-large-kernels-remain-efficient",children:"Deep Large Kernels Remain Efficient"}),"\n",(0,i.jsx)(n.p,{children:"Large kernels are often considered computationally expensive due to increased FLOPs."}),"\n",(0,i.jsx)(n.p,{children:"However, using depthwise convolutions can significantly mitigate this issue."}),"\n",(0,i.jsx)(n.p,{children:"On the other hand, modern GPUs and parallel computing devices have limited support for depthwise convolutions, increasing memory access costs."}),"\n",(0,i.jsx)(n.p,{children:"Existing deep learning tools also lack adequate support for depthwise convolutions, resulting in high inference latency with PyTorch implementations, as shown below."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img1",src:s(58972).A+"",width:"1460",height:"322"})}),"\n",(0,i.jsx)(n.p,{children:"To address this, the authors released an efficient PyTorch implementation, reducing depthwise convolution latency from 49.5% to 12.3%, roughly proportional to FLOPs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/DingXiaoH/RepLKNet-pytorch",children:(0,i.jsx)(n.strong,{children:"RepLKNet-pytorch"})})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"large-kernels-heavily-rely-on-residual-connections",children:"Large Kernels Heavily Rely on Residual Connections"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img2",src:s(43627).A+"",width:"1200",height:"344"})}),"\n",(0,i.jsx)(n.p,{children:"Using MobileNet-V2 for benchmarking, the authors replaced all DW 3\xd73 layers with 13\xd713 layers."}),"\n",(0,i.jsx)(n.p,{children:"The table shows that large kernels improve the accuracy of MobileNet-V2 with shortcuts by 0.77%. Without shortcuts, large kernels reduce accuracy to only 53.98%."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"As seen in previous studies, shortcuts create implicit ensembles of models with different receptive fields, benefiting from a larger maximum receptive field without losing the ability to capture small-scale patterns."})}),"\n",(0,i.jsx)(n.h3,{id:"large-kernels-require-reparameterization",children:"Large Kernels Require Reparameterization"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img3",src:s(65582).A+"",width:"1788",height:"282"})}),"\n",(0,i.jsx)(n.p,{children:"The table shows that directly increasing kernel size from 9 to 13 reduces accuracy, but reparameterization resolves this issue."}),"\n",(0,i.jsx)(n.p,{children:"It is known that ViT faces optimization problems with small datasets. A common solution is to introduce convolutional priors, such as adding a DW 3\xd73 convolution to each self-attention block, similar to this study. These strategies introduce additional translation invariance and locality, making optimization easier on small datasets without losing generality."}),"\n",(0,i.jsx)(n.p,{children:"Similarly, the authors found that reparameterization can be omitted without performance degradation when the pre-training dataset is increased to 73 million images."}),"\n",(0,i.jsx)(n.h3,{id:"large-kernels-significantly-enhance-downstream-task-performance",children:"Large Kernels Significantly Enhance Downstream Task Performance"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img4",src:s(1205).A+"",width:"1116",height:"426"})}),"\n",(0,i.jsx)(n.p,{children:"The table shows that increasing the kernel size from 3\xd73 to 9\xd79 in MobileNet V2 improves ImageNet accuracy by 1.33% and Cityscapes mIoU by 3.99%."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img5",src:s(96888).A+"",width:"1536",height:"528"})}),"\n",(0,i.jsx)(n.p,{children:"Another experiment shows a similar trend: as kernel size increases from [3, 3, 3, 3] to [31, 29, 27, 13], ImageNet accuracy improves by only 0.96%, while ADE20K mIoU increases by 3.12%. This indicates that models with similar ImageNet scores can have very different capabilities in downstream tasks."}),"\n",(0,i.jsx)(n.p,{children:"The authors attribute this to two reasons:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'Large kernels significantly increase the effective receptive field (ERF). Numerous studies have shown that "context" information (large ERF) is crucial for many downstream tasks, such as object detection and semantic segmentation.'}),"\n",(0,i.jsx)(n.li,{children:"Large kernels introduce more shape bias to the network. ImageNet images can be correctly classified based on texture or shape, but humans primarily rely on shape cues to recognize objects. Thus, models with stronger shape bias may perform better in downstream tasks."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Recent studies also indicate that ViT has a strong shape bias, partly explaining why ViT excels in transfer tasks. In contrast, traditional CNNs trained on ImageNet tend to have a texture bias."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2105.07197",children:(0,i.jsx)(n.strong,{children:"[21.05] Are convolutional neural networks or transformers more like human vision?"})})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"large-kernels-are-effective-even-with-small-feature-maps",children:"Large Kernels Are Effective Even with Small Feature Maps"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img6",src:s(76871).A+"",width:"1548",height:"366"})}),"\n",(0,i.jsx)(n.p,{children:"The authors enlarged the DW convolution in the final stage of MobileNet V2 to 7\xd77 or 13\xd713, making the kernel size equal to or larger than the feature map size (default 7\xd77). The table shows that while large kernels do not improve ImageNet performance, they significantly boost downstream tasks, increasing Cityscapes mIoU to 74.62%."}),"\n",(0,i.jsx)(n.p,{children:"The authors believe that as kernel size increases, the translational invariance of CNNs does not strictly hold. Adjacent spatial positions' outputs share only part of the kernel weights, transforming through different mappings, as illustrated below. This mechanism might explain the effectiveness of large kernels on small feature maps."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img7",src:s(9130).A+"",width:"1318",height:"428"})}),"\n",(0,i.jsx)(n.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,i.jsx)(n.h3,{id:"network-architecture",children:"Network Architecture"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img8",src:s(80241).A+"",width:"1140",height:"972"})}),"\n",(0,i.jsx)(n.p,{children:"Based on the above insights, the authors proposed a new network architecture, RepLKNet."}),"\n",(0,i.jsx)(n.p,{children:"Firstly, RepLKNet's design focuses on capturing more details in the initial stages through multiple convolution layers. After the initial 3\xd73 convolution and downsampling, a 3\xd73 depthwise separable convolution (DW) layer captures low-level patterns, followed by a 1\xd71 convolution layer and another DW 3\xd73 layer for downsampling. This ensures thorough extraction of detail information in the initial stages."}),"\n",(0,i.jsx)(n.p,{children:"Secondly, each stage (1-4) of RepLKNet contains multiple RepLK blocks. These blocks leverage shortcuts and DW large kernels to enhance performance. Each DW convolution layer uses a 5\xd75 kernel for reparameterization to capture more details."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Although not shown in the diagram above, this part is crucial for performance improvement. These blocks enable efficient feature extraction and processing at different stages."})}),"\n",(0,i.jsx)(n.p,{children:"Additionally, to enhance nonlinearity and cross-channel communication, RepLKNet introduces ConvFFN blocks. These blocks consist of shortcuts, Batch Normalization (BN), two 1\xd71 convolution layers, and GELU activation, similar to feedforward networks (FFN) in Transformers and MLPs."}),"\n",(0,i.jsx)(n.p,{children:"Compared to the classic FFN using Layer Normalization, BN integrates better with convolution operations, improving inference efficiency. This design is inspired by Transformers and MLP networks and has been successfully applied in CNNs."}),"\n",(0,i.jsx)(n.p,{children:"Between different stages, RepLKNet uses Transition Blocks to adjust channel dimensions and perform downsampling. These blocks first increase channel dimensions with a 1\xd71 convolution, then downsample using a DW 3\xd73 convolution, ensuring comprehensive feature extraction and transformation. These transition blocks allow smooth transitions between stages, maintaining information consistency and integrity."}),"\n",(0,i.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,i.jsx)(n.h3,{id:"evaluation-of-large-kernels",children:"Evaluation of Large Kernels"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img9",src:s(8436).A+"",width:"1326",height:"442"})}),"\n",(0,i.jsx)(n.p,{children:"To evaluate the impact of large kernels on RepLKNet, the authors changed kernel sizes while keeping some hyperparameters fixed, observing their performance on classification and semantic segmentation tasks."}),"\n",(0,i.jsx)(n.p,{children:"The results show that increasing kernel size from 3 to 13 improves accuracy on ImageNet, but further enlarging the kernel does not bring significant improvement. However, on ADE20K, expanding the kernel from 13 to 31 results in higher mIoU, highlighting the advantages of large kernels in downstream tasks."}),"\n",(0,i.jsx)(n.p,{children:"This indicates that while large kernels have limited benefits for certain tasks, they are valuable in specific applications."}),"\n",(0,i.jsx)(n.h3,{id:"performance-on-imagenet",children:"Performance on ImageNet"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img10",src:s(16814).A+"",width:"1392",height:"870"})}),"\n",(0,i.jsx)(n.p,{children:"Given the similarities in architecture between RepLKNet and Swin, the authors conducted a detailed comparison."}),"\n",(0,i.jsx)(n.p,{children:"On ImageNet-1K, the authors extended the training schedule of RepLKNet-31B to 300 epochs to ensure a fair comparison. Then, they fine-tuned for 30 epochs with 384\xd7384 input resolution, at a training cost significantly lower than training Swin-B from scratch with 384\xd7384 resolution."}),"\n",(0,i.jsx)(n.p,{children:"Additionally, the authors pre-trained RepLKNet-B and RepLKNet-L on ImageNet-22K and fine-tuned them on ImageNet-1K. RepLKNet-XL was pre-trained on the authors' private semi-supervised dataset MegData73M."}),"\n",(0,i.jsx)(n.p,{children:"The authors also tested the models' throughput on the same 2080Ti GPU with a batch size of 64."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"The results show that although very large kernels are not suitable for ImageNet classification, RepLKNet models achieve a good balance between accuracy and efficiency. For instance, RepLKNet-31B achieved 84.8% accuracy with only ImageNet-1K training, 0.3% higher than Swin-B, and ran 43% faster. Despite RepLKNet-XL having higher FLOPs than Swin-L, it ran faster, emphasizing the efficiency of large kernel designs."}),"\n",(0,i.jsx)(n.h3,{id:"large-kernel-cnns-have-larger-erf-than-deep-small-kernel-models",children:"Large Kernel CNNs Have Larger ERF Than Deep Small Kernel Models"}),"\n",(0,i.jsx)(n.p,{children:"The authors demonstrated that large kernel designs significantly improve CNN performance."}),"\n",(0,i.jsx)(n.p,{children:"Notably, although large kernels can be represented by a series of small convolutions, such as decomposing a 7\xd77 convolution into three stacked 3\xd73 kernels, a question arises:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Why do traditional CNNs with numerous small convolution layers (e.g., ResNets) still underperform compared to large kernel networks?"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The authors argue that a single large kernel is more effective in achieving a large receptive field (ERF) than many small kernels. According to ERF theory, ERF is proportional to ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mi,{children:"K"}),(0,i.jsx)(n.msqrt,{children:(0,i.jsx)(n.mi,{children:"L"})}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(K\\sqrt{L})"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.1767em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"K"}),(0,i.jsx)(n.span,{className:"mord sqrt",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsxs)(n.span,{className:"vlist",style:{height:"0.9267em"},children:[(0,i.jsxs)(n.span,{className:"svg-align",style:{top:"-3em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"mord",style:{paddingLeft:"0.833em"},children:(0,i.jsx)(n.span,{className:"mord mathnormal",children:"L"})})]}),(0,i.jsxs)(n.span,{style:{top:"-2.8867em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"hide-tail",style:{minWidth:"0.853em",height:"1.08em"},children:(0,i.jsx)(n.svg,{xmlns:"http://www.w3.org/2000/svg",width:"400em",height:"1.08em",viewBox:"0 0 400000 1080",preserveAspectRatio:"xMinYMin slice",children:(0,i.jsx)(n.path,{d:"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z"})})})]})]}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.1133em"},children:(0,i.jsx)(n.span,{})})})]})}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]}),", where K is the kernel size, and L is the depth (number of layers)."]}),"\n",(0,i.jsxs)(n.p,{children:["In other words, ",(0,i.jsx)(n.strong,{children:"ERF is mainly influenced by kernel size, followed by depth"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Moreover, increasing depth brings optimization challenges."}),"\n",(0,i.jsx)(n.p,{children:"Although ResNets are thought to overcome this issue, they do not entirely. Studies show that ResNets behave like ensembles of shallow networks, with ERF remaining limited despite increased depth."}),"\n",(0,i.jsx)(n.p,{children:"To support this, the authors conducted an experiment:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img11",src:s(43275).A+"",width:"1544",height:"494"})}),"\n",(0,i.jsx)(n.p,{children:"To visualize ERF, the authors used a simple yet effective method."}),"\n",(0,i.jsxs)(n.p,{children:["They generated an aggregated contribution score matrix ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"A"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mn,{children:"1024"}),(0,i.jsx)(n.mo,{children:"\xd7"}),(0,i.jsx)(n.mn,{children:"1024"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"A (1024\xd71024)"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"A"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord",children:"1024"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1024"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),", measuring the contribution of corresponding pixels in the input image to the center point of the final layer's feature map."]}),"\n",(0,i.jsxs)(n.p,{children:["In simpler terms: ",(0,i.jsx)(n.strong,{children:"Which pixels in the input image contribute to the center point of the feature map?"})]}),"\n",(0,i.jsx)(n.p,{children:"The results show that in ResNet, ERF is very limited, even with increased depth. In contrast, RepLKNet exhibits more uniformly distributed high-contribution pixels, resulting in a larger ERF."}),"\n",(0,i.jsx)(n.h3,{id:"shape-bias",children:"Shape Bias"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img12",src:s(75580).A+"",width:"996",height:"1028"})}),"\n",(0,i.jsx)(n.p,{children:"The authors note that large kernel designs introduce a stronger shape bias, crucial for downstream tasks."}),"\n",(0,i.jsx)(n.p,{children:"They measured the shape bias of RepLKNet-31B and Swin-B, trained on ImageNet-1K or 22K, and two small kernel baselines, RepLKNet-3 and ResNet-152."}),"\n",(0,i.jsx)(n.p,{children:"The results show that RepLKNet-31B has a significantly higher shape bias than Swin Transformer and small kernel CNNs. The authors believe that shape bias is closely related to ERF rather than self-attention, explaining:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"ViT's high shape bias due to global attention"}),"\n",(0,i.jsx)(n.li,{children:"Swin Transformer's low shape bias due to local window attention"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsx)(n.p,{children:"While large kernel designs significantly enhance CNN performance on ImageNet and downstream tasks, RepLKNet begins to lag behind Swin Transformers as the data and model scale increase."}),"\n",(0,i.jsx)(n.p,{children:"The authors are unsure whether this gap is due to suboptimal hyperparameter tuning or fundamental flaws in CNNs with larger data and model scales."}),"\n",(0,i.jsx)(n.p,{children:"This remains an open area for future research."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"In this study, the authors revisited the long-neglected design of large convolutional kernels in CNN architecture."}),"\n",(0,i.jsx)(n.p,{children:"Through experiments, they demonstrated that using a few large kernels instead of many small ones can more effectively achieve a larger effective receptive field, significantly improving CNN performance. This finding helps narrow the performance gap between CNNs and ViTs."}),"\n",(0,i.jsx)(n.p,{children:"For the CNN community, the results suggest that special attention should be given to ERF, which may be key to achieving high performance. For the ViT community, the study shows that large convolutional kernels can replace multi-head self-attention mechanisms with similar behavior, potentially aiding in understanding the intrinsic mechanisms of self-attention."}),"\n",(0,i.jsx)(n.p,{children:"The authors hope this work fosters mutual understanding and progress between the two communities and inspires further research to explore and optimize deep learning model architecture design."})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},58972:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img1-222d061bc955a73aa4af9101cc77b839.jpg"},16814:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img10-f10a0f047adff656d27d98343a13eec3.jpg"},43275:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img11-d5c2db9c884456b97a2ae5b9e253a464.jpg"},75580:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img12-2b8671d93a2ef1c0c860a7796a1c85bd.jpg"},43627:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img2-28c80f7f6e53734a93305913f115564a.jpg"},65582:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img3-7577b785adb3ce0e46040fbbe83e3056.jpg"},1205:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img4-7b24555c5e3d38eff197e8090f5a1f4f.jpg"},96888:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img5-9d9cb49c653b1ea12b4d0c5c9dc4323b.jpg"},76871:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img6-c9b037aa23e2c85cfeedfff047fdb9ee.jpg"},9130:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img7-9f8a761150efe82a433cb51afa5d93ca.jpg"},80241:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img8-13c0ba4be7a10e75433f67ebbe642d30.jpg"},8436:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/img9-4c86c7455c6b73f91609117353d26cd8.jpg"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(96540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);