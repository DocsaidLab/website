"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["23367"],{45829:function(n,e,t){t.r(e),t.d(e,{metadata:()=>i,contentTitle:()=>a,default:()=>h,assets:()=>l,toc:()=>c,frontMatter:()=>s});var i=JSON.parse('{"id":"capybara/funcs/vision/morphology/imtophat","title":"imtophat","description":"imtophat(img Union[int, Tuple[int, int]] = (3, 3), kstruct: Union[str, int, \\"MORPH\\"] = \\"MORPH.RECT\\") -> np.ndarray","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/capybara/funcs/vision/morphology/imtophat.md","sourceDirName":"capybara/funcs/vision/morphology","slug":"/capybara/funcs/vision/morphology/imtophat","permalink":"/en/docs/capybara/funcs/vision/morphology/imtophat","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"zephyr-sh","lastUpdatedAt":1734922413000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"imopen","permalink":"/en/docs/capybara/funcs/vision/morphology/imopen"},"next":{"title":"videotools","permalink":"/en/docs/category/videotools"}}'),r=t("85893"),o=t("50065");let s={},a="imtophat",l={},c=[];function p(n){let e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"imtophat",children:"imtophat"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/DocsaidLab/Capybara/blob/975d62fba4f76db59e715c220f7a2af5ad8d050e/capybara/vision/morphology.py#L163",children:'imtophat(img: np.ndarray, ksize: Union[int, Tuple[int, int]] = (3, 3), kstruct: Union[str, int, "MORPH"] = "MORPH.RECT") -> np.ndarray'})}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Description"}),": Top-hat operation: The original image minus the result of the opening operation. For multi-channel images, each channel is processed independently. This operation is useful for extracting brighter areas than the original image, such as bright spots or small structures, while removing or reducing large bright areas."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"img"})," (",(0,r.jsx)(e.code,{children:"np.ndarray"}),"): The input image."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ksize"})," (",(0,r.jsx)(e.code,{children:"Union[int, Tuple[int, int]]"}),"): The size of the structuring element. Default is (3, 3)."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"kstruct"})," (",(0,r.jsx)(e.code,{children:"MORPH"}),'): The shape of the structuring element, which can be one of "MORPH.CROSS", "MORPH.RECT", or "MORPH.ELLIPSE". Default is "MORPH.RECT".']}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import numpy as np\nimport capybara as cb\n\nimg = np.array([[1, 1, 1, 0, 0],\n                [1, 1, 1, 0, 0],\n                [1, 1, 1, 0, 0],\n                [0, 0, 1, 1, 0],\n                [0, 0, 0, 1, 1],\n                [0, 0, 0, 1, 1]], dtype=np.uint8)\n\ntophat_img = cb.imtophat(img, ksize=3, kstruct='RECT')\n\n# Kernel will be like this:\n# >>> np.array([[1, 1, 1],\n#               [1, 1, 1],\n#               [1, 1, 1]], dtype=np.uint8)\n\n# After tophat, the image will be like this:\n# >>> np.array([[0, 0, 0, 0, 0],\n#               [0, 0, 0, 0, 0],\n#               [0, 0, 0, 0, 0],\n#               [0, 0, 1, 1, 0],\n#               [0, 0, 0, 0, 0],\n#               [0, 0, 0, 0, 0]], dtype=np.uint8)\n"})}),"\n"]}),"\n"]})]})}function h(n={}){let{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}},50065:function(n,e,t){t.d(e,{Z:function(){return a},a:function(){return s}});var i=t(67294);let r={},o=i.createContext(r);function s(n){let e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);