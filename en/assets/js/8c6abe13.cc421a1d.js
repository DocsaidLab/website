"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8232],{21170:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var t=n(74848),s=n(28453);const o={},a="[19.11] EfficientDet",r={id:"feature-fusion/bifpn/index",title:"[19.11] EfficientDet",description:"The Power of BiFPN",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/feature-fusion/1911-bifpn/index.md",sourceDirName:"feature-fusion/1911-bifpn",slug:"/feature-fusion/bifpn/",permalink:"/en/papers/feature-fusion/bifpn/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:172456154e4,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[19.04] NAS-FPN",permalink:"/en/papers/feature-fusion/nasfpn/"},next:{title:"[19.12] UNet++",permalink:"/en/papers/feature-fusion/unetpp/"}},d={},h=[{value:"The Power of BiFPN",id:"the-power-of-bifpn",level:2},{value:"Defining the Problem",id:"defining-the-problem",level:2},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Model Architecture",id:"model-architecture",level:3},{value:"Model Scaling",id:"model-scaling",level:3},{value:"Weighted Average",id:"weighted-average",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Performance on COCO",id:"performance-on-coco",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const i={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"1911-efficientdet",children:"[19.11] EfficientDet"})}),"\n",(0,t.jsx)(i.h2,{id:"the-power-of-bifpn",children:"The Power of BiFPN"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://arxiv.org/abs/1911.09070",children:(0,t.jsx)(i.strong,{children:"EfficientDet: Scalable and Efficient Object Detection"})})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"Around half a year ago, Google introduced NAS-FPN, but it seems that not everyone within the company agreed it was the best direction. They decided to completely abandon the search results of NAS-FPN and instead reimagined a new feature fusion module based on FPN, which they named BiFPN."}),"\n",(0,t.jsx)(i.h2,{id:"defining-the-problem",children:"Defining the Problem"}),"\n",(0,t.jsx)(i.p,{children:"Since its inception, the pioneering work of FPN has been widely applied to various object detection tasks. Numerous variants and improvements have followed, and we can see a rough development trajectory in the image below:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"FPN",src:n(41250).A+"",width:"1224",height:"432"})}),"\n",(0,t.jsx)(i.p,{children:"Starting from the original FPN on the far left, feature fusion occurs across different resolution feature maps, with the deepest feature map being progressively upsampled and added back to shallower feature maps."}),"\n",(0,t.jsx)(i.p,{children:"PANet later proposed that simply adding features back along one path was insufficient, so they introduced a second path: another round of downsampling and addition. The purpose of this, as we\u2019ve discussed before, is to establish a shortcut for feature fusion from the shallowest to the deepest layers, allowing the model to better utilize different levels of features."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/en/papers/feature-fusion/panet/",children:(0,t.jsx)(i.strong,{children:"[18.03] PANet: Give Me a Shortcut"})})}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"NAS-FPN then introduced an automatic search method, mapping out a multi-layer feature fusion structure, allowing the model to find the optimal fusion strategy on its own. However, this method\u2019s drawbacks are also apparent\u2014it\u2019s difficult to interpret and control."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/en/papers/feature-fusion/nasfpn/",children:(0,t.jsx)(i.strong,{children:"[19.04] NAS-FPN: Money Talks"})})}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"In this paper, the authors from Google decided not to use the NAS approach but instead revisited the strengths of PANet, focusing on two key perspectives:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.strong,{children:"Feature fusion shouldn\u2019t be just a simple addition; it needs to consider the importance of features and perform weighted addition."})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.strong,{children:"The number of FPN layers should scale with the model size."})}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,t.jsx)(i.h3,{id:"model-architecture",children:"Model Architecture"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn arch",src:n(49311).A+"",width:"1322",height:"500"})}),"\n",(0,t.jsx)(i.p,{children:"To demonstrate the effectiveness of BiFPN, the authors selected RetinaNet, a classic object detection model, and replaced the FPN feature fusion module with BiFPN."}),"\n",(0,t.jsx)(i.p,{children:"In the image above, the backbone on the far left is not the focus of this paper, nor is the head on the far right. We should focus solely on the BiFPN in the middle."}),"\n",(0,t.jsx)(i.p,{children:"This design starts with PANet and makes a few improvements, which we\u2019ll illustrate step by step:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Cross-scale connections:"})}),"\n",(0,t.jsx)(i.p,{children:"Starting from PANet, cross-scale connections are added, with each connection involving a \u201cweighted\u201d addition. Therefore, each node introduces a set of weight parameters."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn cross",src:n(71131).A+"",width:"1352",height:"1700"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Removing low-contribution nodes:"})}),"\n",(0,t.jsx)(i.p,{children:"Looking at the above diagram, you\u2019ll notice that the deepest node only has one connection, which is inefficient. It\u2019s better to remove it. Similarly, the shallowest nodes don\u2019t need to receive features from higher levels, so the two nodes are redundant and can also be removed."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn remove",src:n(94156).A+"",width:"1352",height:"1792"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"After these two steps, we arrive at the BiFPN structure."}),"\n",(0,t.jsx)(i.p,{children:"The authors also emphasized an important point: they view this structure as a \u201cmodule.\u201d As such, it can be stacked in layers, allowing for more feature fusion layers as the model size increases."}),"\n",(0,t.jsx)(i.admonition,{type:"tip",children:(0,t.jsx)(i.p,{children:"This concept was not demonstrated in the original PANet, which only had one upsampling and one downsampling layer. With the idea of module stacking, we can apply this to both FPN and PANet, thereby enhancing model performance."})}),"\n",(0,t.jsx)(i.h3,{id:"model-scaling",children:"Model Scaling"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn scale",src:n(81524).A+"",width:"1036",height:"568"})}),"\n",(0,t.jsx)(i.p,{children:"Beyond the new architecture, the authors extended the concept of model scaling from EfficientNet, introducing a scaling concept for the FPN as well."}),"\n",(0,t.jsx)(i.p,{children:"The general idea is that if the backbone can scale, so should the FPN, to better match models of different sizes. The table above shows BiFPN scaling configurations for models of varying sizes. As the model size increases, the number of BiFPN layers and channels also increases."}),"\n",(0,t.jsx)(i.h3,{id:"weighted-average",children:"Weighted Average"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn avg",src:n(27587).A+"",width:"1486",height:"272"})}),"\n",(0,t.jsx)(i.p,{children:"Finally, the authors discussed how to design the weights for the weighted feature maps."}),"\n",(0,t.jsx)(i.p,{children:"Three design methods were proposed in the paper:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Unbounded fusion: No constraints on the weights, allowing the model to learn them freely, but the results were very unstable and were thus disregarded."}),"\n",(0,t.jsx)(i.li,{children:"Softmax fusion: Apply softmax to the weights, ensuring they sum to 1."}),"\n",(0,t.jsx)(i.li,{children:"ReLU constraint: Apply ReLU to ensure weights are positive, and then normalize them to sum to 1."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"In the above figure, the authors show experimental results for the second and third methods. The results indicate that ReLU and Softmax perform similarly, but ReLU is 30% faster, which is why the authors recommend this design."}),"\n",(0,t.jsx)(i.h2,{id:"discussion",children:"Discussion"}),"\n",(0,t.jsx)(i.h3,{id:"performance-on-coco",children:"Performance on COCO"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn coco",src:n(95857).A+"",width:"1224",height:"662"})}),"\n",(0,t.jsx)(i.p,{children:"The authors conducted experiments on the COCO 2017 detection dataset, using 118,000 training images."}),"\n",(0,t.jsx)(i.p,{children:"During training, they used the SGD optimizer with a momentum of 0.9 and a weight decay of 4e-5. The learning rate linearly increased from 0 in the initial epochs to 0.16, followed by a cosine decay schedule. Additionally, synchronized batch normalization was applied after each convolution operation, with a decay factor of 0.99 and an epsilon of 1e-3."}),"\n",(0,t.jsx)(i.p,{children:"The model employed SiLU (Swish-1) as the activation function and applied an exponential moving average with a decay factor of 0.9998 to improve stability. During training, the focal loss function was used, with \u03b1 set to 0.25 and \u03b3 to 1.5. Data augmentation strategies included horizontal flipping and scale jittering, with image sizes randomly adjusted to 0.1 to 2.0 times the original size before cropping. Furthermore, soft non-maximum suppression (Soft NMS) was used during evaluation."}),"\n",(0,t.jsx)(i.p,{children:"For training resources, EfficientDet-D0 to D6 models were trained for 300 epochs on 32 TPUv3 cores, while EfficientDet-D7 and D7x models were trained for 600 epochs on 128 TPUv3 cores, with a total batch size of 128."}),"\n",(0,t.jsx)(i.p,{children:"The results demonstrated that EfficientDet models achieved superior efficiency across different precision and resource constraints. Compared to previous detectors, EfficientDet models were 4 to 9 times smaller in size and reduced FLOPs by 13 to 42 times. Notably, EfficientDet-D0 reduced FLOPs by 28 times compared to YOLOv3 while maintaining similar accuracy. Compared to RetinaNet and Mask-RCNN, EfficientDet achieved similar accuracy with 8 times fewer parameters and 21 times fewer FLOPs."}),"\n",(0,t.jsx)(i.p,{children:"In high-precision settings, EfficientDet-D7x achieved 55.1 AP on the COCO test-dev set, significantly surpassing the state of the art, improving accuracy by 4 AP while being 7 times more efficient. The authors also compared inference latency on Titan-V FP32, V100 GPU FP16, and single-thread CPU, highlighting EfficientDet\u2019s advantage in inference speed."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"bifpn speed",src:n(68102).A+"",width:"1452",height:"458"})}),"\n",(0,t.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"Compared to traditional FPN architectures, BiFPN achieves better multi-scale feature fusion by leveraging selective weighting and lightweight design, all without significantly increasing computational costs."}),"\n",(0,t.jsxs)(i.admonition,{type:"tip",children:[(0,t.jsx)(i.p,{children:"Simple and effective, BiFPN is a great companion for implementing models. We highly recommend giving it a try."}),(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://github.com/DocsaidLab/DocsaidKit/blob/main/docsaidkit/torch/neck/bifpn.py",children:(0,t.jsx)(i.strong,{children:"docsaidkit/torch/neck/bifpn"})})}),"\n"]})]})]})}function l(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},41250:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img2-d660993f3684ac06681968c9e33da95f.jpg"},49311:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img3-34e38a23a3eaa918e094bcba71530b38.jpg"},71131:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img3_1-0db50a671010016d27163912b3e7612d.jpg"},94156:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img3_2-65fa9539f6c02ffd3ec6c25e0a4906b5.jpg"},81524:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img4-579acc5148b829dd8fe24f9b0485209f.jpg"},95857:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img5-94b0d555f36a63cc6cda997146fe04cc.jpg"},68102:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img6-ede76eaeaaa28ff6c4731e7a94898c52.jpg"},27587:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/img7-561083838099bed404fcb860253ac5e4.jpg"},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>r});var t=n(96540);const s={},o=t.createContext(s);function a(e){const i=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);