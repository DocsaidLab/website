"use strict";(self.webpackChunkdocsaid_website=self.webpackChunkdocsaid_website||[]).push([["49340"],{31900:function(e,n,i){i.r(n),i.d(n,{frontMatter:()=>a,default:()=>h,toc:()=>c,metadata:()=>s,assets:()=>l,contentTitle:()=>o});var s=JSON.parse('{"id":"object-detection/yolov6/index","title":"[22.09] YOLOv6","description":"The Crossroad of Re-parameterization","source":"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/object-detection/2209-yolov6/index.md","sourceDirName":"object-detection/2209-yolov6","slug":"/object-detection/yolov6/","permalink":"/en/papers/object-detection/yolov6/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"zephyr-sh","lastUpdatedAt":1749728215000,"frontMatter":{"title":"[22.09] YOLOv6","authors":"Z. Yuan"},"sidebar":"papersSidebar","previous":{"title":"[22.07] YOLOv7","permalink":"/en/papers/object-detection/yolov7/"},"next":{"title":"[24.01] YOLO-World","permalink":"/en/papers/object-detection/yolo-world/"}}'),t=i(85893),r=i(50065);let a={title:"[22.09] YOLOv6",authors:"Z. Yuan"},o=void 0,l={},c=[{value:"The Crossroad of Re-parameterization",id:"the-crossroad-of-re-parameterization",level:2},{value:"Problem Definition",id:"problem-definition",level:2},{value:"Problem Solving",id:"problem-solving",level:2},{value:"Network Design",id:"network-design",level:3},{value:"Label Assignment",id:"label-assignment",level:3},{value:"Loss Function",id:"loss-function",level:3},{value:"Quantization and Deployment",id:"quantization-and-deployment",level:3},{value:"Implementation Details",id:"implementation-details",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Comparison with Other Architectures",id:"comparison-with-other-architectures",level:3},{value:"Ablation Studies",id:"ablation-studies",level:3},{value:"Quantization Results",id:"quantization-results",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"the-crossroad-of-re-parameterization",children:"The Crossroad of Re-parameterization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2209.02976",children:(0,t.jsx)(n.strong,{children:"YOLOv6: A Single-Stage Object Detection Framework for Industrial Applications"})})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"Since YOLOv5 was never formally published, we directly move on to v6."}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6 is developed under the leadership of the computer vision team at Meituan, a Chinese lifestyle service platform."}),"\n",(0,t.jsx)(n.h2,{id:"problem-definition",children:"Problem Definition"}),"\n",(0,t.jsx)(n.p,{children:"The YOLO series has always enjoyed extremely high popularity in industrial applications."}),"\n",(0,t.jsx)(n.p,{children:"The reason is simple: it\u2019s straightforward, fast, and accurate enough."}),"\n",(0,t.jsx)(n.p,{children:"However, as task types expand and deployment scenarios become more complex, the foundational assumptions once considered \u201Cgood enough\u201D gradually become insufficient."}),"\n",(0,t.jsx)(n.p,{children:"For example, the myth of architectural consistency causes a performance gap between small and large models; the instability of quantized inference results in re-parameterized models producing adverse effects during practical deployment."}),"\n",(0,t.jsx)(n.p,{children:"Moreover, current speed reports mostly rely on high-end GPUs, causing a large discrepancy between expected and actual latency in deployment; advanced training strategies such as label assignment, loss design, and knowledge distillation often remain theoretical or limited to small-scale experiments, making it hard to form a complete training pipeline."}),"\n",(0,t.jsx)(n.p,{children:"At the core lies a fundamental question:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"When we say a model is fast and accurate enough, what do we really mean?"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Is it the benchmark score on an A100 GPU, or real-time response on a T4? Is it the endpoint of the training accuracy curve, or the ability to run stably in industrial settings for a month?"}),"\n",(0,t.jsx)(n.p,{children:"These accumulated questions are not just technical details but also reflect differing design philosophies."}),"\n",(0,t.jsx)(n.p,{children:"Looking back at the YOLO architecture, past development focused on module stacking, feature fusion, and data augmentation. However, before reaching the threshold of industrial deployment, the core that needs reconsideration is:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"model quantizability, module re-parameterizability, training strategies, and hardware friendliness."})}),"\n",(0,t.jsx)(n.h2,{id:"problem-solving",children:"Problem Solving"}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6 breaks down its design philosophy into six strategic aspects addressing six long-standing engineering bottlenecks:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Network Design"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Label Assignment"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Loss Function"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Training Enhancements (Industry-handy Improvements)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Quantization and Deployment"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Self-distillation"})}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"The YOLO series introduces re-parameterized architectures starting from this paper, a concept that gained popularity following the 2021 RepVGG paper. For readers who haven't yet read RepVGG, you can refer to our previous notes:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/en/papers/reparameterization/repvgg/",children:(0,t.jsx)(n.strong,{children:"[21.01] RepVGG: Making VGG Great Again"})})}),"\n"]})]}),"\n",(0,t.jsx)(n.h3,{id:"network-design",children:"Network Design"}),"\n",(0,t.jsx)(n.p,{children:"An object detection model can basically be decomposed into three core modules:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Backbone, Neck, and Head."})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These terms should be familiar to everyone."}),"\n",(0,t.jsx)(n.p,{children:"The Backbone dominates feature extraction, determining the semantic representation ability of the model and accounting for most of the computational cost; the Neck integrates feature maps at different levels, building a multi-scale pyramid structure; the Head performs classification and bounding box prediction based on these feature maps."}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6 redesigns all three modules with differentiated adjustments according to different model sizes. The core idea is:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Design different architectures for different model scales."})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For small models, YOLOv6 uses the ",(0,t.jsx)(n.strong,{children:"RepBlock"})," re-parameterizable module as the main Backbone. This conversion mechanism is inspired by RepVGG\u2019s design philosophy: ",(0,t.jsx)(n.strong,{children:"training is for learning, inference is optimized for deployment."})]}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"90%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"RepBlock",src:i(17994).Z+"",width:"1068",height:"488"})})})}),"\n",(0,t.jsx)(n.p,{children:"The RepBlock module, shown in figure (a) above, contains a multi-branch structure during training, which facilitates feature representation learning; during inference, it is converted into a single-path, stacked 3\xd73 convolution form that maximizes hardware computation density and parallel efficiency, performing particularly well on mainstream GPUs and CPUs."}),"\n",(0,t.jsxs)(n.p,{children:["However, when scaling up the model size, the single-path architecture causes parameters and computations to grow exponentially. Therefore, YOLOv6 introduces a new design for medium and large models: the ",(0,t.jsx)(n.strong,{children:"CSPStackRep Block"}),", shown in figure (c). This is a hybrid module combining the ",(0,t.jsx)(n.strong,{children:"CSP structure"})," with the ",(0,t.jsx)(n.strong,{children:"RepBlock re-parameterization mechanism."})]}),"\n",(0,t.jsx)(n.p,{children:"Internally, it consists of three 1\xd71 convolutions and a stack of RepBlocks, incorporating cross-stage residual connections (CSP) to maintain performance stability while reducing redundant computation. This structure achieves a better trade-off between accuracy and speed, especially suitable for medium to large models."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"Next, looking at the Neck."}),"\n",(0,t.jsxs)(n.p,{children:["YOLOv6 continues to use the ",(0,t.jsx)(n.strong,{children:"PAN (Path Aggregation Network)"})," architecture from v4/v5 as the main Neck. The difference is that small models use RepBlock, while larger models use CSPStackRep Block to replace v5\u2019s original CSPBlock."]}),"\n",(0,t.jsxs)(n.p,{children:["This architecture is named ",(0,t.jsx)(n.strong,{children:"Rep-PAN"})," by the authors. Its width and depth dynamically adjust according to model scale, allowing features to flow effectively across different levels and spatial scales, while maintaining inference efficiency."]}),"\n",(0,t.jsx)(n.p,{children:"The overall architecture is shown below:"}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"90%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"RepPAN",src:i(31882).Z+"",width:"1552",height:"360"})})})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"Finally, the Head design optimization."}),"\n",(0,t.jsxs)(n.p,{children:["Compared to v5\u2019s coupled design or YOLOX\u2019s decoupled Head with two extra 3\xd73 convolution layers, YOLOv6 adopts a decoupled design called ",(0,t.jsx)(n.strong,{children:"Efficient Decoupled Head"}),", which retains only one intermediate convolutional layer and adjusts overall channel counts based on Backbone and Neck widths."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, YOLOv6 uses an ",(0,t.jsx)(n.strong,{children:"anchor-free"})," approach based on anchor points. The model no longer assumes a preset set of anchor boxes but directly predicts the distance from each point to the object boundary. This method offers simple decoding, strong generalization, and low post-processing cost. It is also a mainstream design in recent anchor-free detectors such as FCOS and YOLOX."]}),"\n",(0,t.jsx)(n.h3,{id:"label-assignment",children:"Label Assignment"}),"\n",(0,t.jsx)(n.p,{children:"Label assignment is a critical step in the object detection training pipeline."}),"\n",(0,t.jsx)(n.p,{children:"It is responsible for assigning each ground-truth object to a set of predefined anchors or prediction points during training. This process not only determines the distribution of positive and negative samples but also directly affects the learning dynamics of both classification and regression branches."}),"\n",(0,t.jsx)(n.p,{children:"Early methods mostly relied on geometric criteria, such as IoU-based strategies or rules based on whether a point lies inside a bounding box. These approaches are intuitive but often insufficient for handling multi-scale objects and uneven backgrounds."}),"\n",(0,t.jsx)(n.p,{children:"In recent years, advanced methods have emerged that treat label assignment as an optimization or task alignment problem."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SimOTA: An ideal transport problem with suboptimal convergence"})}),"\n",(0,t.jsxs)(n.p,{children:["Early versions of YOLOv6 adopted ",(0,t.jsx)(n.strong,{children:"SimOTA"})," as the label assignment strategy."]}),"\n",(0,t.jsx)(n.p,{children:"This method is derived from OTA (Optimal Transport Assignment), modeling label assignment as a global transport problem and using the loss function as the distance metric to achieve an overall optimal allocation between classification and regression results."}),"\n",(0,t.jsx)(n.p,{children:"SimOTA simplifies OTA by retaining its core idea while reducing hyperparameter complexity. However, in practice, the authors observed several issues:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Introducing SimOTA ",(0,t.jsx)(n.strong,{children:"significantly lengthened training time"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["The model tended to exhibit ",(0,t.jsx)(n.strong,{children:"unstable oscillations"})," during early training stages and was more sensitive to initialization and learning rates."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These observations led them to seek a more stable and training-friendly alternative."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"TAL: Task alignment from geometry to semantics"})}),"\n",(0,t.jsxs)(n.p,{children:["Ultimately, the authors adopted ",(0,t.jsx)(n.strong,{children:"Task Alignment Learning (TAL)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Proposed by TOOD, unlike SimOTA, TAL ",(0,t.jsx)(n.strong,{children:"no longer relies solely on geometric metrics (e.g., IoU) as assignment criteria"}),", but establishes a unified metric considering both classification scores and predicted box quality, enabling synchronous alignment of classification and regression branches during label assignment."]}),"\n",(0,t.jsx)(n.p,{children:"This design brings two clear advantages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mitigates task misalignment between classification and regression"}),", enhancing overall model consistency;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Demonstrates stability and accelerated convergence from early training stages"}),", with less reliance on hyperparameter tuning."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"TOOD\u2019s original architecture also introduced T-head and TAP (Task-Aligned Predictor) modules. Later, PP-YOLOE simplified this to the ET-head."}),"\n",(0,t.jsx)(n.p,{children:"However, the authors found that incorporating ET-head in YOLOv6 did not yield significant accuracy improvements and slowed inference speed. Therefore, they retained their Efficient Decoupled Head design and adopted TAL only for label assignment."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["Experiments confirmed that TAL not only outperforms SimOTA in accuracy but more importantly, ",(0,t.jsx)(n.strong,{children:"significantly stabilizes the training process"}),", becoming YOLOv6\u2019s default label assignment mechanism."]}),"\n",(0,t.jsx)(n.h3,{id:"loss-function",children:"Loss Function"}),"\n",(0,t.jsxs)(n.p,{children:["The object detection task can essentially be decomposed into two subtasks: ",(0,t.jsx)(n.strong,{children:"classification"})," and ",(0,t.jsx)(n.strong,{children:"localization"}),", corresponding to classification loss and bounding box regression loss. These two loss paths influence prediction accuracy as well as the overall convergence speed and stability."]}),"\n",(0,t.jsx)(n.p,{children:"In YOLOv6, the authors conducted extensive experiments on loss design for these subtasks and ultimately selected a balanced combination strategy."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Classification Loss: Balancing signal strength between positive and negative samples"})}),"\n",(0,t.jsx)(n.p,{children:"For the classification branch, traditional cross-entropy loss tends to cause the model to overfit easy samples and ignore a small number of hard samples due to class imbalance. Focal Loss was proposed to address this by down-weighting easy samples, focusing training on harder examples."}),"\n",(0,t.jsx)(n.p,{children:"Further extensions include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Quality Focal Loss (QFL)"}),", which integrates classification confidence with predicted box quality for supervision;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Poly Loss"}),", which expands the loss polynomially to improve generalization;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"VariFocal Loss (VFL)"}),", which asymmetrically handles positives and negatives by assigning stronger signals to positive samples, further balancing the signal distribution."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Through experiments, ",(0,t.jsx)(n.strong,{children:"YOLOv6 ultimately selects VFL as the classification loss"}),", primarily due to its high sensitivity to hard samples and stable training behavior."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Bounding Box Loss: From IoU to probability distribution"})}),"\n",(0,t.jsx)(n.p,{children:"The core of localization loss design is to make predicted boxes as close as possible to ground truth. Early methods used L1 or L2 loss but found inconsistencies with evaluation metrics (such as IoU), causing misdirected learning."}),"\n",(0,t.jsx)(n.p,{children:"Therefore, IoU-based losses were proposed, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GIoU, DIoU, CIoU"}),": incorporating geometric information such as enclosing box area, center distance, and aspect ratio;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SIoU"}),": further considering convergence behaviors along diagonal and angular directions."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6 adopts the following strategy:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Small models (YOLOv6-N/T) use ",(0,t.jsx)(n.strong,{children:"SIoU"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["Medium and large models use ",(0,t.jsx)(n.strong,{children:"GIoU"})," to balance stability and performance."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, YOLOv6 introduces ",(0,t.jsx)(n.strong,{children:"Distribution Focal Loss (DFL)"})," in medium and large models. This loss treats box regression as a probability distribution estimation, better handling ambiguous or uncertain object boundaries. Considering its computational cost, ",(0,t.jsx)(n.strong,{children:"DFL is only used in YOLOv6-M/L"}),", not in smaller models."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Objectness Loss: A design without gains"})}),"\n",(0,t.jsxs)(n.p,{children:["The authors also experimented with adding an ",(0,t.jsx)(n.strong,{children:"objectness loss"})," similar to FCOS and YOLOX, aimed at suppressing low-quality predicted boxes. However, experiments showed that in YOLOv6\u2019s anchor-free architecture, ",(0,t.jsx)(n.strong,{children:"this design brought no significant benefits"})," and thus was excluded from the final model."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["Overall, YOLOv6\u2019s loss design follows a ",(0,t.jsx)(n.strong,{children:"task-alignment plus signal-enhancement"})," strategy:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The classification branch emphasizes signal asymmetry, using VFL to stabilize discrimination;"}),"\n",(0,t.jsx)(n.li,{children:"The regression branch prioritizes stable and fast learning in small models, while allowing complex but precise DFL in large models;"}),"\n",(0,t.jsxs)(n.li,{children:["All designs aim to ",(0,t.jsx)(n.strong,{children:"improve overall learning quality without sacrificing inference efficiency"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"quantization-and-deployment",children:"Quantization and Deployment"}),"\n",(0,t.jsx)(n.p,{children:"In industrial applications, speed is essential."}),"\n",(0,t.jsxs)(n.p,{children:["Therefore, ",(0,t.jsx)(n.strong,{children:"how to accelerate inference without severely sacrificing performance"})," becomes a practical challenge beyond model design and training."]}),"\n",(0,t.jsx)(n.p,{children:"Quantization is the primary solution to this problem."}),"\n",(0,t.jsx)(n.p,{children:"However, for architectures like YOLOv6 that heavily utilize re-parameterization blocks, traditional quantization workflows are not directly applicable."}),"\n",(0,t.jsx)(n.p,{children:"Using Post-Training Quantization (PTQ) leads to a significant drop in accuracy; switching to Quantization-Aware Training (QAT) introduces mismatches between the quantization simulator during training and actual inference, causing additional issues."}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:"Before moving on, let\u2019s pause here."}),(0,t.jsx)(n.p,{children:"Shortly after this paper was published, another classic study on quantization issues for re-parameterized architectures appeared: QARepVGG."}),(0,t.jsx)(n.p,{children:"This paper points out that the cause of quantization problems lies in BatchNorm collapse during the re-parameterization process due to certain statistical parameter issues. Interested readers can refer to our previous notes:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/en/papers/reparameterization/qarepvgg/",children:(0,t.jsx)(n.strong,{children:"[22.12] QARepVGG: Making RepVGG Great Again"})})}),"\n"]})]}),"\n",(0,t.jsx)(n.p,{children:"At this moment, YOLOv6 tackles the problem step-by-step."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"RepOptimizer: Solving quantization issues at the optimizer level for re-parameterized blocks"})}),"\n",(0,t.jsxs)(n.p,{children:["YOLOv6 uses ",(0,t.jsx)(n.strong,{children:"RepOptimizer"})," as its training optimizer, a gradient optimization strategy designed specifically for re-parameterized architectures. The core idea is to perform structural-level re-parameterization during every gradient update, aligning training and deployment behaviors from the source."]}),"\n",(0,t.jsx)(n.p,{children:"Experiments (see figure below) show that models trained this way have a narrower feature distribution range, making them more suitable for direct Post-Training Quantization (PTQ). This enables producing a quantized model with stable inference performance without requiring additional large-scale annotated data."}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"70%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"rep-optimizer",src:i(98050).Z+"",width:"808",height:"588"})})})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Sensitivity Analysis: Protecting fragile parts of the model with float precision"})}),"\n",(0,t.jsxs)(n.p,{children:["Even when trained with RepOptimizer, some layers may still suffer significant accuracy drops after quantization. Therefore, YOLOv6 applies ",(0,t.jsx)(n.strong,{children:"sensitivity analysis"})," to evaluate the quantization impact on feature maps layer-by-layer and identify the most sensitive layers."]}),"\n",(0,t.jsx)(n.p,{children:"Evaluation metrics used include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"MSE (Mean Squared Error)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"SNR (Signal-to-Noise Ratio)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Cosine Similarity"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"After comprehensive analysis on the YOLOv6-S model, the authors choose to keep the top six most sensitive layers in full float precision, while safely quantizing the rest. This mixed-precision deployment strategy effectively improves stability without adding extra complexity."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"QAT + Channel-wise Distillation"})}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"80%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Channel-wise Distillation",src:i(69491).Z+"",width:"908",height:"584"})})})}),"\n",(0,t.jsx)(n.p,{children:"In some deployment scenarios, even RepOptimizer combined with mixed precision is insufficient, thus further Quantization-Aware Training (QAT) is needed. YOLOv6 makes two improvements on this basis:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"QAT must be built on top of the RepOptimizer framework to solve inconsistencies caused by fake quantizers;"}),"\n",(0,t.jsx)(n.li,{children:"It incorporates Channel-wise Distillation, where the FP32 model outputs serve as teacher signals to guide the quantized training process."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This self-distillation design further improves channel-level distribution learning, compensating for details lost during quantization."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6\u2019s training pipeline largely follows YOLOv5\u2019s setup, including these techniques and strategies:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Optimizer: Stochastic Gradient Descent (SGD) with momentum;"}),"\n",(0,t.jsx)(n.li,{children:"Learning rate schedule: Cosine decay;"}),"\n",(0,t.jsx)(n.li,{children:"Other techniques: Warm-up initialization, grouped weight decay, and exponential moving average (EMA)."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For data augmentation, the authors adopt two widely validated strong augmentations: ",(0,t.jsx)(n.strong,{children:"Mosaic"})," and ",(0,t.jsx)(n.strong,{children:"Mixup"}),", continuing the practice from YOLOv4/YOLOv5."]}),"\n",(0,t.jsx)(n.p,{children:"Training data comes from COCO 2017 training set; validation uses the COCO 2017 validation set."}),"\n",(0,t.jsx)(n.p,{children:"All models are trained on 8 NVIDIA A100 GPUs. Unless otherwise noted, speed tests are performed on Tesla T4 using TensorRT 7.2."}),"\n",(0,t.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,t.jsx)(n.p,{children:"This paper dedicates considerable space to planning and experiments on self-distillation, but due to space constraints, we highlight only a few key results here. Readers interested in self-distillation techniques are encouraged to consult the original paper."}),"\n",(0,t.jsx)(n.h3,{id:"comparison-with-other-architectures",children:"Comparison with Other Architectures"}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"90%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"result",src:i(9715).Z+"",width:"1408",height:"482"})})})}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"70%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"result",src:i(41228).Z+"",width:"1224",height:"872"})})})}),"\n",(0,t.jsx)(n.p,{children:"Since YOLOv6\u2019s core goal is to build an efficient detector for industrial deployment, the authors focus not on FLOPs or parameter counts but on actual inference efficiency after deployment, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Throughput (FPS):"})," inference frame rate at batch sizes 1 and 32;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Latency:"})," average per-image processing delay."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Experiments compare the YOLOv6 series with other YOLO-family models:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"YOLOv5"}),"\n",(0,t.jsx)(n.li,{children:"YOLOX"}),"\n",(0,t.jsx)(n.li,{children:"PP-YOLOE"}),"\n",(0,t.jsx)(n.li,{children:"YOLOv7"}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Wait, why can v6 be compared with v7?"})}),(0,t.jsx)(n.p,{children:"Because v7 was released earlier than v6! Welcome to the chaotic world of YOLO! \uD83D\uDE31"})]}),"\n",(0,t.jsxs)(n.p,{children:["All models were tested under identical conditions: ",(0,t.jsx)(n.strong,{children:"FP16 precision + TensorRT deployment + Tesla T4 GPU"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"YOLOv7-Tiny results were re-tested using its open-source models and official weights at input sizes 416 and 640."}),"\n",(0,t.jsx)(n.p,{children:"Key takeaways from the experiments:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"YOLOv6-N"})," achieves ",(0,t.jsx)(n.strong,{children:"7.9% / 2.6% AP improvements over YOLOv5-N / YOLOv7-Tiny"})," at input size 416, with best throughput and latency metrics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"YOLOv6-S"})," outperforms YOLOX-S / PPYOLOE-S by ",(0,t.jsx)(n.strong,{children:"3.0% / 0.4% AP"}),", also running faster."]}),"\n",(0,t.jsxs)(n.li,{children:["At input size 640, ",(0,t.jsx)(n.strong,{children:"YOLOv6-T"})," improves accuracy by ",(0,t.jsx)(n.strong,{children:"2.9%"})," over YOLOv5-S / YOLOv7-Tiny and is faster by ",(0,t.jsx)(n.strong,{children:"73 / 25 FPS"})," at batch size 1."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"YOLOv6-M"})," gains ",(0,t.jsx)(n.strong,{children:"4.2% AP over YOLOv5-M"})," and ",(0,t.jsx)(n.strong,{children:"2.7% / 0.6% over YOLOX-M / PPYOLOE-M"}),", while maintaining speed advantages."]}),"\n",(0,t.jsxs)(n.li,{children:["In large model comparisons, ",(0,t.jsx)(n.strong,{children:"YOLOv6-L"})," surpasses YOLOX-L / PPYOLOE-L by ",(0,t.jsx)(n.strong,{children:"2.8% / 1.1% AP"})," while leading in latency."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The authors also propose a faster variant, ",(0,t.jsx)(n.strong,{children:"YOLOv6-L-ReLU"}),", which replaces SiLU activation with ReLU. Without increasing latency, it achieves ",(0,t.jsx)(n.strong,{children:"51.7% AP with only 8.8ms delay"}),", outperforming YOLOX-L, PPYOLOE-L, and YOLOv7 in both accuracy and speed."]}),"\n",(0,t.jsx)(n.h3,{id:"ablation-studies",children:"Ablation Studies"}),"\n",(0,t.jsxs)(n.p,{children:["To verify the impact of design choices on final performance, systematic ablation experiments cover three aspects: ",(0,t.jsx)(n.strong,{children:"network architecture, label assignment, and loss functions"}),". Experiments mainly use YOLOv6-N/S/M models under consistent training and testing setups."]}),"\n",(0,t.jsx)(n.p,{children:"First, performance of single-path vs. multi-branch (CSPStackRep Block) structures is compared across model scales."}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"70%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"backbone ablation",src:i(52043).Z+"",width:"1036",height:"504"})})})}),"\n",(0,t.jsx)(n.p,{children:"Results show:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["On YOLOv6-N, ",(0,t.jsx)(n.strong,{children:"single-path structure"})," outperforms multi-branch in accuracy and speed. Despite higher FLOPs and parameters, lower memory footprint and better parallelism lead to faster runtime."]}),"\n",(0,t.jsx)(n.li,{children:"YOLOv6-S shows comparable performance between both structures."}),"\n",(0,t.jsxs)(n.li,{children:["For YOLOv6-M/L, ",(0,t.jsx)(n.strong,{children:"multi-branch structure"})," performs better; authors select CSPStackRep with channel coefficients of 2/3 (M) and 1/2 (L)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Analysis of YOLOv6-L\u2019s Neck width and depth reveals that narrow-and-deep design yields 0.2% higher AP with similar speed, aligning with expectations that deeper architectures have larger receptive fields suited for detection."}),"\n",(0,t.jsx)(n.p,{children:"Additional conclusions include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Conv + SiLU achieves best accuracy."}),"\n",(0,t.jsx)(n.li,{children:"RepConv + ReLU balances speed and accuracy well."}),"\n",(0,t.jsx)(n.li,{children:"Adding Decoupled Head (DH) improves AP by 1.4% with only 5% more computation."}),"\n",(0,t.jsx)(n.li,{children:"Anchor-free design increases inference speed by 51% compared to anchor-based, mainly due to reduced output dimensions."}),"\n",(0,t.jsx)(n.li,{children:"Unified Backbone and Neck redesign (EB+RN) improves AP by 3.6% and speed by 21%."}),"\n",(0,t.jsx)(n.li,{children:"Hybrid-channel Decoupled Head (HC) adds 0.2% AP and boosts FPS by 6.8%."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For label assignment, ",(0,t.jsx)(n.strong,{children:"TAL"})," proves best, achieving ",(0,t.jsx)(n.strong,{children:"35.0% AP on YOLOv6-N"}),", 0.5% higher than SimOTA, with more stable training."]}),"\n",(0,t.jsx)(n.p,{children:"Loss function comparisons among VFL, QFL, Focal Loss, and Poly Loss show VFL yields AP improvements of 0.2% / 0.3% / 0.1% on YOLOv6-N/S/M, becoming the default classification loss."}),"\n",(0,t.jsx)(n.p,{children:"Tests on IoU-based and distribution-based losses find:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SIoU"})," best for YOLOv6-N and YOLOv6-T;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CIoU"})," better for YOLOv6-M;"]}),"\n",(0,t.jsx)(n.li,{children:"DFL adds 0.1\u20130.2% gain but slows small models, thus used only in YOLOv6-M/L."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Objectness loss experiments show introducing it on YOLOv6-N/S/M causes up to 1.1% AP drop. The authors attribute this to TAL\u2019s alignment logic becoming disrupted by adding a third task branch, hence opting to exclude objectness loss."}),"\n",(0,t.jsx)(n.h3,{id:"quantization-results",children:"Quantization Results"}),"\n",(0,t.jsxs)(n.p,{children:["To validate YOLOv6\u2019s quantization design in deployment, authors conduct complete PTQ and QAT experiments on ",(0,t.jsx)(n.strong,{children:"YOLOv6-S"}),", testing both v1.0 and v2.0 models trained for 300 epochs by default."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"The biggest improvement in v2.0 is the removal of quantization-sensitive layers, such as certain composite activations, shortcut structures, and misaligned convolution modules."})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Post-Training Quantization (PTQ)"})}),"\n",(0,t.jsx)(n.p,{children:"Comparison of PTQ effects with and without RepOptimizer shows:"}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"70%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"ptq",src:i(19243).Z+"",width:"956",height:"380"})})})}),"\n",(0,t.jsxs)(n.p,{children:["RepOptimizer does not affect FP32 accuracy but ",(0,t.jsx)(n.strong,{children:"significantly improves INT8 quantized accuracy"}),", especially in v1.0, from 35.0% to 40.9%. This demonstrates its ability to converge feature distributions, aiding quantization error tolerance."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Quantization-Aware Training (QAT)"})}),"\n",(0,t.jsxs)(n.p,{children:["For YOLOv6 v1.0, ",(0,t.jsx)(n.strong,{children:"Partial QAT"})," is applied to non-sensitive layers, comparing Full QAT and Channel-wise Distillation (CW Distill):"]}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"70%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"qat",src:i(27123).Z+"",width:"940",height:"216"})})})}),"\n",(0,t.jsx)(n.p,{children:"Partial QAT outperforms Full QAT overall, improving accuracy by 7.3% with only slight throughput reduction. This confirms the effectiveness of selectively choosing quantization blocks to minimize accuracy loss."}),"\n",(0,t.jsx)(n.p,{children:"For v2.0, with quantization-sensitive layers removed, QAT can be applied network-wide. Combined with graph optimizations and quantization module simplifications, accuracy and speed improve further."}),"\n",(0,t.jsx)(n.p,{children:"Comparison with PaddleSlim\u2019s quantized models shows:"}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)("figure",{style:{width:"70%"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"qat",src:i(40108).Z+"",width:"952",height:"340"})})})}),"\n",(0,t.jsx)(n.p,{children:"Results indicate the proposed quantization method outperforms other publicly available quantized models in both accuracy and speed, even surpassing YOLOv6 FP16 in speed while maintaining only 0.1% lower accuracy."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["These results demonstrate that through ",(0,t.jsx)(n.strong,{children:"RepOptimizer + selective QAT + graph optimization + channel-wise distillation"}),", YOLOv6 not only achieves quantization but does so efficiently, truly balancing speed and accuracy for deployment."]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6\u2019s main contributions include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Designing re-parameterizable architectures for small models and efficient multi-branch architectures for large models based on model scale differences;"}),"\n",(0,t.jsx)(n.li,{children:"Employing TAL for label assignment and VFL + SIoU/CIoU + DFL loss design, balancing stability and accuracy;"}),"\n",(0,t.jsx)(n.li,{children:"Incorporating engineering techniques such as extended training, self-distillation, gray border handling, and Mosaic augmentation to enhance performance;"}),"\n",(0,t.jsx)(n.li,{children:"Combining RepOptimizer with mixed-precision PTQ/QAT strategies to successfully build deployable quantized detectors."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"YOLOv6 surpasses existing models in accuracy and speed, maintaining strong performance after quantization, providing a practical solution for real-time industrial applications."})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},9715:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img0-02b723e213f54c6b4846f1ee22f3b92d.jpg"},17994:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img1-b0329cfb2268fba5474240d16190cf03.jpg"},31882:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img2-2c5897c1b525b656392ca5cf0c734d26.jpg"},98050:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img3-58f19366000e0707661d8b219423a44e.jpg"},69491:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img4-f401e4abf6312af1beda4f780ade7d1a.jpg"},41228:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img5-ad609b9750e34bb11f93af2a568c0614.jpg"},52043:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img6-dab3d2a9c793d5ff7aeaaddc8ae45416.jpg"},19243:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img7-181ecae8f459f478849553e3ea770bca.jpg"},27123:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img8-1ae3fb0a04ea0f8a246a394a1b7179a3.jpg"},40108:function(e,n,i){i.d(n,{Z:()=>s});let s=i.p+"assets/images/img9-4caa25b96621e3710c71f555a93b4434.jpg"},50065:function(e,n,i){i.d(n,{Z:()=>o,a:()=>a});var s=i(67294);let t={},r=s.createContext(t);function a(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);