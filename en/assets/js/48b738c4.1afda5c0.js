"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2906],{94620:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=n(74848),s=n(28453);const r={sidebar_position:7},o="Discussion",a={id:"docclassifier/discussion",title:"Discussion",description:"Based on our experiments, we have developed a model with promising performance. This model achieved over 90% accuracy on our test set and has demonstrated good results in practical applications.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/docclassifier/discussion.md",sourceDirName:"docclassifier",slug:"/docclassifier/discussion",permalink:"/en/docs/docclassifier/discussion",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1714715772e3,sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Evaluation",permalink:"/en/docs/docclassifier/benchmark"},next:{title:"Training",permalink:"/en/docs/docclassifier/training_env"}},c={},l=[];function d(e){const i={a:"a",code:"code",h1:"h1",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"discussion",children:"Discussion"}),"\n",(0,t.jsx)(i.p,{children:"Based on our experiments, we have developed a model with promising performance. This model achieved over 90% accuracy on our test set and has demonstrated good results in practical applications."}),"\n",(0,t.jsx)(i.p,{children:"Here, we will discuss some of our insights and experiences gained during the training process."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["When considering which Margin loss to use, such as CosFace or ArcFace, it is crucial to pair it with ",(0,t.jsx)(i.a,{href:"https://arxiv.org/abs/2203.15565",children:"PartialFC"}),". This significantly accelerates training speed, stabilizes convergence, and improves performance."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Regarding the variety of categories in text-image classification, we initially started with around 500 categories, then expanded to 800, 10,000, and finally incorporated an indoor dataset to increase the overall classification categories to approximately 400,000. This conclusion aligns with face recognition tasks: the effectiveness of the model is closely related to the diversity of the training data. Therefore, utilizing a large and diverse dataset ensures that the model learns sufficient features and can effectively differentiate between various categories."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Experimentation has shown that adopting ",(0,t.jsx)(i.strong,{children:"low-precision training"})," enhances the model's generalization ability. We believe this is because models are prone to overfitting, and low-precision training helps alleviate this issue. Directly setting low-precision training on the ",(0,t.jsx)(i.code,{children:"trainer"})," is not feasible due to some operators not supporting this setting on CUDA. Therefore, we employed the ",(0,t.jsx)(i.code,{children:"torch.set_float32_matmul_precision('medium')"})," method to achieve low-precision training."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Through experimentation, it was observed that LayerNorm performs better than BatchNorm in text-image classification tasks. This may be attributed to text images (e.g., street signs, document images) typically containing highly variable features, such as different fonts, sizes, and background noise. LayerNorm, by independently normalizing each sample, helps the model handle these variations more effectively. Conversely, in face recognition, using BatchNorm assists the model in learning to differentiate subtle differences from highly similar facial images. This ensures that the model can effectively recognize facial features under various conditions (e.g., lighting, angles, facial expressions)."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"When individually using CosFace and ArcFace, ArcFace showed better performance. However, after incorporating PartialFC, the situation changed, and CosFace performed better."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Pretraining is essential; attempting training without pretraining resulted in very poor performance. This could be due to the insufficient diversity of the provided dataset, necessitating pretraining to help the model learn more features. We once again thank timm for providing models that helped us save a significant amount of time and effort."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["During the concatenation of the Backbone and Head, utilizing ",(0,t.jsx)(i.code,{children:"nn.Flatten"})," to gather all information and integrate it into the feature encoding layer yields the best results. However, the drawback is the substantial parameter overhead. In lightweight model scenarios, even a 1MB increase in model size is significant. Therefore, we explored two directions: using ",(0,t.jsx)(i.code,{children:"nn.GlobalAvgPool2d"})," to gather all information and integrating it into the feature encoding layer with ",(0,t.jsx)(i.code,{children:"nn.Linear"}),", and using ",(0,t.jsx)(i.code,{children:"nn.Conv2d"})," to first reduce the channel dimension to 1/4, referred to as Squeeze, followed by ",(0,t.jsx)(i.code,{children:"nn.Flatten"})," and ",(0,t.jsx)(i.code,{children:"nn.Linear"})," to integrate it into the feature encoding layer. Through experimentation, employing the Squeeze strategy proved effective. This strategy not only significantly reduces model size but also maintains model performance."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Introducing CLIP features is a good strategy as it not only improves model performance but also enhances model generalization. The core of this strategy is using the CLIP model to distill knowledge into our model, thereby incorporating CLIP model features into our model. This strategy has shown very positive results as the CLIP model possesses rich knowledge that helps our model learn more robust feature representations."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Adding a BatchNorm layer after LayerNorm is the key to pushing our model past the 90% mark. We believe this is because the characteristics of LayerNorm and BatchNorm complement each other. LayerNorm helps the model learn more stable features, while BatchNorm aids in learning cross-sample feature representations."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(96540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);