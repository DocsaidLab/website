"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9944],{62327:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var t=i(74848),s=i(28453);const a={},r="[21.11] MAE",o={id:"transformers/vision/mae/index",title:"[21.11] MAE",description:"A Quarter of the Clue",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/transformers/vision/2111-mae/index.md",sourceDirName:"transformers/vision/2111-mae",slug:"/transformers/vision/mae/",permalink:"/en/papers/transformers/vision/mae/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1725965282e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[21.10] MobileViT",permalink:"/en/papers/transformers/vision/mobilevit/"},next:{title:"[21.11] PoolFormer",permalink:"/en/papers/transformers/vision/poolformer/"}},h={},d=[{value:"A Quarter of the Clue",id:"a-quarter-of-the-clue",level:2},{value:"Defining the Problem",id:"defining-the-problem",level:2},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Model Architecture",id:"model-architecture",level:3},{value:"Training Method",id:"training-method",level:3},{value:"Discussion",id:"discussion",level:2},{value:"How Much Masking is Optimal?",id:"how-much-masking-is-optimal",level:3},{value:"Decoder Parameters",id:"decoder-parameters",level:3},{value:"Learning Targets",id:"learning-targets",level:3},{value:"Data Augmentation",id:"data-augmentation",level:3},{value:"Masking Strategy",id:"masking-strategy",level:3},{value:"Performance on ImageNet",id:"performance-on-imagenet",level:3},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"2111-mae",children:"[21.11] MAE"})}),"\n",(0,t.jsx)(n.h2,{id:"a-quarter-of-the-clue",children:"A Quarter of the Clue"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2111.06377",children:(0,t.jsx)(n.strong,{children:"Masked Autoencoders Are Scalable Vision Learners"})})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"In the field of NLP, the most famous pre-training method is Masked Language Modeling (Mask LM). Simply put, 15% of the tokens in the input data are masked, and the model is trained to predict the content of the masked tokens. This classic learning paradigm has given rise to many successful models such as BERT, RoBERTa, and ALBERT."}),"\n",(0,t.jsx)(n.p,{children:"But what about images?"}),"\n",(0,t.jsx)(n.p,{children:"Why doesn't the vision domain have a similar pre-training method?"}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-problem",children:"Defining the Problem"}),"\n",(0,t.jsx)(n.p,{children:"When ViT was proposed, similar experiments had already been conducted."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/en/papers/transformers/vision/vit/",children:(0,t.jsx)(n.strong,{children:"[20.10] ViT: Pioneering a New Frontier"})})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In the paper, the authors emulated the Mask LM approach by masking parts of the image and having the model predict the masked portions. They also explored the differences between predicting pixels versus regions."}),"\n",(0,t.jsx)(n.p,{children:"The conclusion was: neither worked well."}),"\n",(0,t.jsx)(n.p,{children:"Neither self-supervised training method outperformed supervised methods."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["The authors of this paper believe the main issue lies in the difference between the ",(0,t.jsx)(n.strong,{children:"information density of language and vision"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Language is a human-generated signal with high semantic and informational density. When training a model to predict a few missing words in a sentence, the task seems to trigger complex language understanding. In contrast, images are natural signals with significant spatial redundancy. The model can recover the missing information from neighboring patches without needing a high-level understanding of parts, objects, or scenes."}),"\n",(0,t.jsx)(n.p,{children:"For the model, it can simply interpolate from nearby patches to restore most of the information, without any real incentive to learn deeply. Naturally, the final results are disappointing."}),"\n",(0,t.jsx)(n.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,t.jsx)(n.p,{children:"To overcome this disparity, the authors decided to mask most of the patches\u2014how about 75%?"}),"\n",(0,t.jsx)(n.h3,{id:"model-architecture",children:"Model Architecture"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae arch",src:i(50766).A+"",width:"1224",height:"716"})}),"\n",(0,t.jsx)(n.p,{children:"Unlike the architecture discussed in the ViT paper, some changes were made here."}),"\n",(0,t.jsx)(n.p,{children:"Initially, as before, the image is split into patches, and some patches are randomly masked. To avoid center bias, the masked patches are randomly sampled."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Encoder"})}),"\n",(0,t.jsx)(n.p,{children:"This is where things start to differ."}),"\n",(0,t.jsx)(n.p,{children:"The masked patches are not fed into the Encoder model, nor do they contribute to the loss calculation. The model only trains on the unmasked patches."}),"\n",(0,t.jsx)(n.p,{children:"The advantage of this approach is that it allows the model to be trained using a smaller portion of the data, reducing computational costs while still training a large model. When it comes to inference, removing all the masks reveals the full capabilities of the model."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Decoder"})}),"\n",(0,t.jsx)(n.p,{children:'Here, an auxiliary Decoder model is introduced for training purposes. The input to the Decoder is the "complete" image sequence, including the masked patches. The masked patches contain only positional information, with no other content.'}),"\n",(0,t.jsx)(n.p,{children:"The model's goal is to predict the masked patches and compare them to the original image to calculate the loss."}),"\n",(0,t.jsx)(n.p,{children:"After pre-training, this entire module can be discarded, leaving only the Encoder."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"training-method",children:"Training Method"}),"\n",(0,t.jsx)(n.p,{children:"MAE reconstructs the input by predicting the pixel values of each masked patch. The final layer of the Decoder is a linear projection, with the number of output channels equal to the number of pixel values in a patch."}),"\n",(0,t.jsx)(n.p,{children:"The loss function is the Mean Squared Error (MSE) between the reconstructed image and the original image in pixel space. Training is only conducted on the masked patches, not the entire image."}),"\n",(0,t.jsx)(n.p,{children:"The authors included numerous illustrations in the paper to ensure readers understood the concept. Here's one of the images:"}),"\n",(0,t.jsx)(n.p,{children:"On the left is the input image with masks, in the middle is the Decoder\u2019s output, and on the right is the original image."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae train",src:i(23257).A+"",width:"1224",height:"864"})}),"\n",(0,t.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae result",src:i(33319).A+"",width:"936",height:"100"})}),"\n",(0,t.jsx)(n.p,{children:"The authors first optimized the ViT training method, boosting the top-1 accuracy from 76.5% to 82.5% as the model baseline."}),"\n",(0,t.jsx)(n.p,{children:"The MAE approach further improved the model's performance to 84.9%, a staggering result."}),"\n",(0,t.jsx)(n.h3,{id:"how-much-masking-is-optimal",children:"How Much Masking is Optimal?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae mask",src:i(9532).A+"",width:"1128",height:"704"})}),"\n",(0,t.jsx)(n.p,{children:"The authors experimented with two scenarios: Fine-tuning and Linear-probing."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"The difference is that Fine-tuning directly fine-tunes the pre-trained model, while Linear-probing freezes the pre-trained model and only trains the final classifier."})}),"\n",(0,t.jsx)(n.p,{children:"As shown in the image above, when the masking ratio exceeds 80%, performance starts to drop. The optimal performance is between 40% and 80%. Based on the Linear-probing results, the authors chose a 75% masking ratio."}),"\n",(0,t.jsx)(n.p,{children:"It\u2019s particularly noteworthy that inputting masked patches during the Encoder stage leads to a significant performance drop (14%). This is because this approach misaligns the model's training and deployment phases, hindering learning."}),"\n",(0,t.jsx)(n.h3,{id:"decoder-parameters",children:"Decoder Parameters"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae decoder",src:i(94314).A+"",width:"1226",height:"350"})}),"\n",(0,t.jsx)(n.p,{children:"The authors further explored the impact of Decoder parameters on the final results."}),"\n",(0,t.jsx)(n.p,{children:"The experiments showed that a Decoder depth of 8 layers worked best, and the Decoder width didn\u2019t need to match the Encoder\u2019s width (dim=1024); about half the width sufficed."}),"\n",(0,t.jsx)(n.h3,{id:"learning-targets",children:"Learning Targets"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae target",src:i(61653).A+"",width:"968",height:"318"})}),"\n",(0,t.jsx)(n.p,{children:"The results in this paper are based on reconstructing the original pixels, but the authors also explored other learning targets, such as predicting PCA components or dVAE latent variables."}),"\n",(0,t.jsx)(n.p,{children:"These alternatives didn\u2019t perform as well as reconstructing original pixels, though predicting normalized pixel values showed promising results."}),"\n",(0,t.jsx)(n.h3,{id:"data-augmentation",children:"Data Augmentation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae aug",src:i(54392).A+"",width:"1020",height:"350"})}),"\n",(0,t.jsx)(n.p,{children:"The authors tested data augmentation methods like random cropping and rotation during training. The results showed that these augmentations weren\u2019t necessary\u2014 the model achieved the best results using the original images."}),"\n",(0,t.jsx)(n.p,{children:"This contrasts sharply with contrastive learning methods, which heavily rely on data augmentation. For example, in methods like BYOL and SimCLR, performance drops significantly without augmentation."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2002.05709",children:(0,t.jsx)(n.strong,{children:"[20.02] A Simple Framework for Contrastive Learning of Visual Representations"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2006.07733",children:(0,t.jsx)(n.strong,{children:"[20.06] Bootstrap your own latent: A new approach to self-supervised Learning"})})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"masking-strategy",children:"Masking Strategy"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae mask",src:i(37123).A+"",width:"964",height:"344"})}),"\n",(0,t.jsx)(n.p,{children:"In addition to the proposed masking strategy, the authors tested several other approaches:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"random: random masking"}),"\n",(0,t.jsx)(n.li,{children:"block: block masking"}),"\n",(0,t.jsx)(n.li,{children:"grid: grid masking"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The differences are shown below:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae mask type",src:i(72422).A+"",width:"1224",height:"488"})}),"\n",(0,t.jsx)(n.p,{children:"The experiments revealed that block masking performs well at a 50% masking ratio but falls short at a 75% ratio compared to random masking. The random method allows for the most extensive masking, incorporating it into model training while providing the best results."}),"\n",(0,t.jsx)(n.h3,{id:"performance-on-imagenet",children:"Performance on ImageNet"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mae imagenet",src:i(89716).A+"",width:"1080",height:"312"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Comparison of Self-Supervised Methods"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For the ViT-B model, the performance differences between methods are minimal."}),"\n",(0,t.jsx)(n.li,{children:"For the ViT-L model, the differences are more significant, highlighting the challenge of reducing overfitting in larger models."}),"\n",(0,t.jsx)(n.li,{children:"The MAE method scales well, consistently improving accuracy on larger models."}),"\n",(0,t.jsx)(n.li,{children:"Using the ViT-H model (224 size), the MAE method achieved 86.9% accuracy; when resized to 448, the accuracy increased to 87.8% using only IN1K data."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Comparison with State-of-the-Art Methods"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Among all methods using only IN1K data, the MAE method surpasses the previous best accuracy (87.1%) achieved by advanced networks."}),"\n",(0,t.jsx)(n.li,{children:"The MAE method is more accurate than the BEiT model, simpler, faster to train (3.5x per epoch), and doesn\u2019t require dVAE pre-training."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The MAE model undergoes 1600 epochs of pre-training to enhance accuracy, yet the total pre-training time is still less than other methods. Compared to supervised pre-training, the MAE method helps scale up the model and demonstrates better performance."}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"In image processing, light signals don\u2019t have the clear semantic decomposition found in text, yet MAE can generate detailed image reconstructions, indicating that it captures many critical visual concepts."}),"\n",(0,t.jsx)(n.p,{children:"This is reminiscent of the success in the NLP domain. We can see that the vision field is developing along a similar trajectory, albeit in a different way."}),"\n",(0,t.jsx)(n.p,{children:"Many subsequent studies have borrowed from this approach, incorporating MAE techniques into their training processes to improve model performance. We will share these related studies as we encounter them in the future."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},50766:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img1-4fc6d3790a2abc9a5eb0d39d0aee53cd.jpg"},89716:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img10-d50d8f69ee99185f3d51e211b92ea4ab.jpg"},23257:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img2-7ebe25201ba63811424d9d18b6abdd18.jpg"},9532:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img3-9c8317bf5ec2569fb37db0000b370e8f.jpg"},33319:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img4-1a95f1f338eb00fb228c010061d6193b.jpg"},94314:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img5-9dc61adc7b31da4985c795d029f58bf1.jpg"},61653:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img6-6c649fc1759de8b4b2637f8a9783ed99.jpg"},54392:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img7-660d94b5d54d2e2d06260e2f81f8f2a8.jpg"},37123:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img8-28ba9c64f77809947f133a8fa8e85f4a.jpg"},72422:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img9-dcd6b8237aa65b75949baa911ef79a24.jpg"},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(96540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);