"use strict";(self.webpackChunkdocsaid_website=self.webpackChunkdocsaid_website||[]).push([["65581"],{68337:function(e,n,i){i.r(n),i.d(n,{default:()=>u,frontMatter:()=>r,metadata:()=>t,assets:()=>d,toc:()=>c,contentTitle:()=>a});var t=JSON.parse('{"id":"capybara/funcs/structures/pairwise_ioa","title":"pairwise_ioa","description":"pairwise_ioa(boxes1 Boxes) -> np.ndarray","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/capybara/funcs/structures/pairwise_ioa.md","sourceDirName":"capybara/funcs/structures","slug":"/capybara/funcs/structures/pairwise_ioa","permalink":"/en/docs/capybara/funcs/structures/pairwise_ioa","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"zephyr-sh","lastUpdatedAt":1734942587000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"pairwise_iou","permalink":"/en/docs/capybara/funcs/structures/pairwise_iou"},"next":{"title":"polygon_iou","permalink":"/en/docs/capybara/funcs/structures/polygon_iou"}}'),o=i("85893"),s=i("50065");let r={sidebar_position:8},a="pairwise_ioa",d={},c=[{value:"Additional Information",id:"additional-information",level:2},{value:"Introduction to IoA",id:"introduction-to-ioa",level:3},{value:"Definition",id:"definition",level:3},{value:"Calculation Steps",id:"calculation-steps",level:3},{value:"Applications",id:"applications",level:3},{value:"Advantages and Limitations",id:"advantages-and-limitations",level:3}];function l(e){let n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"pairwise_ioa",children:"pairwise_ioa"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/DocsaidLab/Capybara/blob/975d62fba4f76db59e715c220f7a2af5ad8d050e/capybara/structures/functionals.py#L70",children:"pairwise_ioa(boxes1: Boxes, boxes2: Boxes) -> np.ndarray"})}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Description"}),":"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"pairwise_ioa"})," is a function used to calculate the Intersection over Area (IoA) between two lists of bounding boxes. This function computes the IoA for all N x M pairs of bounding boxes. The input bounding boxes must be of type ",(0,o.jsx)(n.code,{children:"Boxes"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"boxes1"})," (",(0,o.jsx)(n.code,{children:"Boxes"}),"): The first list of bounding boxes, containing N bounding boxes."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"boxes2"})," (",(0,o.jsx)(n.code,{children:"Boxes"}),"): The second list of bounding boxes, containing M bounding boxes."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import capybara as cb\n\nboxes1 = cb.Boxes([[10, 20, 50, 80], [20, 30, 60, 90]])\nboxes2 = cb.Boxes([[20, 30, 60, 90], [30, 40, 70, 100]])\nioa = cb.pairwise_ioa(boxes1, boxes2)\nprint(ioa)\n# >>> [[0.625 0.33333334]\n#      [1.0 0.625]]\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"additional-information",children:"Additional Information"}),"\n",(0,o.jsx)(n.h3,{id:"introduction-to-ioa",children:"Introduction to IoA"}),"\n",(0,o.jsx)(n.p,{children:"IoA (Intersection over Area) is a metric used to evaluate the overlap between bounding boxes. It measures the ratio of the intersection area to the area of the ground truth bounding box."}),"\n",(0,o.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,o.jsx)(n.p,{children:"The IoA formula is the intersection area of the predicted and ground truth bounding boxes divided by the area of the ground truth bounding box. The IoA value ranges from 0 to 1, with higher values indicating better overlap between the predicted and ground truth bounding boxes."}),"\n",(0,o.jsx)(n.h3,{id:"calculation-steps",children:"Calculation Steps"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Determine Bounding Box Coordinates"}),": The first step is to determine the position of both the predicted and ground truth bounding boxes in the image. These are usually represented by four coordinates: (x0, y0, x1, y1), where (x0, y0) is the top-left corner and (x1, y1) is the bottom-right corner."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Calculate Intersection Area"}),": Compute the intersection area between the predicted and ground truth bounding boxes."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Calculate IoA"}),": Divide the intersection area by the area of the ground truth bounding box to get the IoA value."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"applications",children:"Applications"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Object Detection"}),": In object detection tasks, IoA is used to evaluate how well the predicted bounding boxes overlap with the ground truth, helping assess the accuracy of the detection model."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Model Evaluation"}),": IoA is commonly used to assess and compare the performance of different object detection models. Higher IoA values indicate better detection accuracy."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Non-Maximum Suppression (NMS)"}),": In post-processing of object detection, IoA is used in non-maximum suppression to eliminate overlapping detection boxes and retain the best results."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"advantages-and-limitations",children:"Advantages and Limitations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Advantages"}),": IoA quantifies the overlap between predicted and ground truth bounding boxes, providing a clear metric for model accuracy."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Limitations"}),": IoA only considers the overlap between the predicted and ground truth bounding boxes and does not account for other factors, such as the shape or orientation of the bounding boxes. Therefore, it may not be sufficiently accurate in certain scenarios."]}),"\n"]}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},50065:function(e,n,i){i.d(n,{Z:function(){return a},a:function(){return r}});var t=i(67294);let o={},s=t.createContext(o);function r(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);