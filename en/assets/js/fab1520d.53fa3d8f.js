"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4670],{16539:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var s=n(74848),a=n(28453);const i={},o="[19.11] GhostNet",r={id:"ghostnet/index",title:"[19.11] GhostNet",description:"Ghost in Feature Maps",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/1911-ghostnet/index.md",sourceDirName:"1911-ghostnet",slug:"/ghostnet/",permalink:"/en/papers/ghostnet/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:172376997e4,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[19.05] MobileNet-V3",permalink:"/en/papers/mobilenet-v3/"},next:{title:"[20.10] ViT",permalink:"/en/papers/vit/"}},l={},h=[{value:"Ghost in Feature Maps",id:"ghost-in-feature-maps",level:2},{value:"Defining the Problem",id:"defining-the-problem",level:2},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Model Architecture",id:"model-architecture",level:3},{value:"Module Configuration",id:"module-configuration",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Performance on ImageNet",id:"performance-on-imagenet",level:3},{value:"Actual Inference Speed",id:"actual-inference-speed",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",admonition:"admonition",annotation:"annotation",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",math:"math",mi:"mi",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"1911-ghostnet",children:"[19.11] GhostNet"}),"\n",(0,s.jsx)(t.h2,{id:"ghost-in-feature-maps",children:"Ghost in Feature Maps"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://arxiv.org/abs/1911.11907",children:(0,s.jsx)(t.strong,{children:"GhostNet: More Features from Cheap Operations"})})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"After the introduction of MobileNet, many researchers continued to work on improving the performance of lightweight networks."}),"\n",(0,s.jsx)(t.p,{children:'This paper specifically addresses the problem of "feature map redundancy."'}),"\n",(0,s.jsx)(t.h2,{id:"defining-the-problem",children:"Defining the Problem"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"problem",src:n(81248).A+"",width:"1224",height:"816"})}),"\n",(0,s.jsx)(t.p,{children:"Feature maps in convolutional networks typically contain a lot of redundant information, which consumes computational resources and adversely affects the network's performance."}),"\n",(0,s.jsx)(t.p,{children:"The image above is a simple example showing that some areas of the feature map are repetitive, which might not significantly contribute to the network's performance."}),"\n",(0,s.jsx)(t.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,s.jsx)(t.p,{children:"Generally, there are two common approaches: model compression and making the model more compact."}),"\n",(0,s.jsx)(t.h3,{id:"model-architecture",children:"Model Architecture"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"model_arch",src:n(94863).A+"",width:"972",height:"904"})}),"\n",(0,s.jsx)(t.p,{children:"In GhostNet, the authors proposed a new model architecture, as shown above."}),"\n",(0,s.jsx)(t.p,{children:"Unlike typical convolutional networks, the GhostNet module operates in two steps:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:'First, a convolution operation is used to compress the input feature map, obtaining a "base feature map" A.'}),"\n",(0,s.jsx)(t.li,{children:'Then, linear operations are applied to each channel of the base feature map A to generate "ghost feature maps" B.'}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Finally, the base feature map A and the ghost feature maps B are concatenated to obtain the final feature map."}),"\n",(0,s.jsx)(t.p,{children:"These linear operations are much simpler than convolution operations, significantly reducing the computational load of GhostNet."}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:'The "Cheap" linear operation of each channel mentioned in the paper is actually grouped convolution. This method can reduce the amount of calculation and improve efficiency.'})}),"\n",(0,s.jsx)(t.h3,{id:"module-configuration",children:"Module Configuration"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"model_arch2",src:n(22482).A+"",width:"856",height:"744"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Ghost Bottlenecks"})}),"\n",(0,s.jsx)(t.p,{children:"Leveraging the advantages of the ghost module, the authors introduced ghost bottlenecks (G-bnecks) designed specifically for small CNNs. This design is similar to the basic residual blocks in ResNet, combining multiple convolution layers and shortcuts."}),"\n",(0,s.jsx)(t.p,{children:"The ghost bottleneck primarily consists of two stacked ghost modules. The first ghost module acts as an expansion layer, increasing the number of channels, with the expansion ratio defined as the ratio of the output channels to the input channels. The second ghost module reduces the number of channels to match the shortcut path and connects the input and output of these two ghost modules through a shortcut."}),"\n",(0,s.jsx)(t.p,{children:"Batch normalization (BN) and ReLU non-linearity are applied to each layer. Additionally, following MobileNetV2's suggestion, ReLU is not used after the second ghost module."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"GhostNet"})}),"\n",(0,s.jsx)(t.p,{children:"Based on ghost bottlenecks, the authors proposed GhostNet."}),"\n",(0,s.jsx)(t.p,{children:"This architecture generally follows the design of MobileNetV3, replacing its bottleneck blocks with ghost bottlenecks. GhostNet mainly consists of a series of ghost bottlenecks, starting with a standard convolution layer with 16 filters, followed by a series of ghost bottlenecks with gradually increasing channels. These ghost bottlenecks are divided into different stages based on the size of the input feature maps."}),"\n",(0,s.jsx)(t.p,{children:"Except for the last bottleneck of each stage, which has a stride of 2, all other bottlenecks have a stride of 1. Finally, the feature map is converted to a 1280-dimensional feature vector for final classification through global average pooling and a convolution layer."}),"\n",(0,s.jsx)(t.p,{children:"In some ghost bottlenecks, the residual layer also applies squeeze-and-excitation (SE) modules. Compared to MobileNetV3, GhostNet does not use hard activation functions (hard-swish) due to their higher latency."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Width Multiplier"}),":"]}),"\n",(0,s.jsx)(t.p,{children:"Although the basic architecture of GhostNet already provides low latency and high accuracy, in some cases, smaller, faster models or higher accuracy for specific tasks may be required."}),"\n",(0,s.jsxs)(t.p,{children:["To meet different needs, the number of channels in each layer can be multiplied by a factor ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"\u03b1"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\alpha"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"})]})})]}),", known as the width multiplier. This uniformly changes the width of the entire network, controlling the model size and computational cost by approximately ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"\u03b1"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\alpha"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"})]})})]})," squared."]}),"\n",(0,s.jsxs)(t.p,{children:["Generally, smaller ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"\u03b1"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\alpha"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"})]})})]})," leads to lower latency and performance, while larger ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"\u03b1"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\alpha"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"})]})})]})," improves performance. This design flexibility allows GhostNet to adapt to different application scenarios and requirements."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The final model configuration is shown in the table below:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"module_config",src:n(47969).A+"",width:"960",height:"1080"})}),"\n",(0,s.jsx)(t.h2,{id:"discussion",children:"Discussion"}),"\n",(0,s.jsx)(t.h3,{id:"performance-on-imagenet",children:"Performance on ImageNet"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"imagenet_performance2",src:n(47731).A+"",width:"1224",height:"732"})}),"\n",(0,s.jsx)(t.p,{children:"To verify the superiority of the proposed GhostNet, the authors conducted experiments on the ImageNet image classification task."}),"\n",(0,s.jsx)(t.p,{children:"Following the training settings used in past literature, with an initial learning rate of 0.4 when the batch size is 1024 and trained on 8 GPUs. All results are reported using the top-1 accuracy on the ImageNet validation set with single-crop evaluation. For GhostNet, the kernel size in the primary convolution is set to k = 1, and parameters s = 2 and d = 3 are used in all ghost modules, which is a simple setup."}),"\n",(0,s.jsx)(t.p,{children:"The authors selected several modern small network architectures as competitors, including the MobileNet series, ShuffleNet series, ProxylessNAS, FBNet, and MnasNet, with results summarized in the table above."}),"\n",(0,s.jsx)(t.p,{children:"These models are divided into three computational complexity levels, typically suitable for mobile applications, i.e., around 50, 150, and 200-300 MFLOPs. From the results, it is evident that larger FLOPs generally lead to higher accuracy among these small networks, demonstrating their effectiveness. GhostNet consistently outperforms other competitors at various levels of computational complexity because GhostNet is more efficient in utilizing computational resources to generate feature maps."}),"\n",(0,s.jsx)(t.h3,{id:"actual-inference-speed",children:"Actual Inference Speed"}),"\n",(0,s.jsx)(t.p,{children:"Since the proposed GhostNet is designed for mobile applications, the authors further measured the actual inference speed of GhostNet on an ARM-based mobile phone using TFLite tools. In single-thread mode with a batch size of 1, they used common settings from the literature."}),"\n",(0,s.jsx)(t.p,{children:"From the results below, it can be seen that GhostNet achieves approximately 0.5% higher top-1 accuracy than MobileNetV3 at the same latency, and GhostNet requires less runtime to achieve similar performance. For instance, GhostNet has only 40ms latency at 75.0% accuracy, whereas MobileNetV3 requires about 45ms to process an image at a similar accuracy level."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"imagenet_performance",src:n(69924).A+"",width:"3703",height:"1352"})}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.p,{children:"In the paper, the test inference speed is based on ARM architecture mobile phones and tested with TF-Lite. In fact, the author did not mention which mobile phone to use. Based on our own experience, the same configuration and model will perform differently on different brands of mobile phones."}),(0,s.jsx)(t.p,{children:"Therefore, we recommend that readers conduct their own experiments when using GhostNet to ensure that its inference speed meets their needs."})]}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"To reduce the computational cost of current deep neural networks, this paper proposes a novel ghost module for building efficient neural network architectures. This method is a plug-and-play module that can convert the original model into a compact model while maintaining comparable performance."}),"\n",(0,s.jsx)(t.p,{children:"In the process of developing neural networks, the GhostNet architecture can be a viable option, especially in resource-constrained scenarios, potentially offering more possibilities."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},81248:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/img1-11948cfd0acaf23356c3dd46f4d134c9.jpg"},94863:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/img2-70f5f77ff2f6d24255665011e802d569.jpg"},22482:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/img3-4aacb498713be7f53a53ef36e5a5c215.jpg"},47969:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/img4-ce7b41cb93d902cc8242fe11f900ce7a.jpg"},69924:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/img5-bac0d90d26ef7d7122863ad6f78c70f8.jpg"},47731:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/img6-2ecfb97b3c955624c8c5fcbab4dde402.jpg"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);