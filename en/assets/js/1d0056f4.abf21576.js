"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4995],{6669:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=s(74848),i=s(28453);const r={},a="[18.10] BERT",o={id:"transformers/bert/index",title:"[18.10] BERT",description:"Twelve Layers of Encoders",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/transformers/1810-bert/index.md",sourceDirName:"transformers/1810-bert",slug:"/transformers/bert/",permalink:"/en/papers/transformers/bert/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1726039819e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[18.06] GPT-1",permalink:"/en/papers/transformers/gpt_1/"},next:{title:"[19.01] Transformer-XL",permalink:"/en/papers/transformers/transformer-xl/"}},l={},d=[{value:"Twelve Layers of Encoders",id:"twelve-layers-of-encoders",level:2},{value:"Defining the Problem",id:"defining-the-problem",level:2},{value:"Unidirectionality",id:"unidirectionality",level:3},{value:"Solving the Problem",id:"solving-the-problem",level:2},{value:"Model Architecture",id:"model-architecture",level:3},{value:"Pre-training Strategy",id:"pre-training-strategy",level:3},{value:"Fine-tuning Strategy",id:"fine-tuning-strategy",level:3},{value:"Discussion",id:"discussion",level:2},{value:"Ablation Study",id:"ablation-study",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"1810-bert",children:"[18.10] BERT"})}),"\n",(0,t.jsx)(n.h2,{id:"twelve-layers-of-encoders",children:"Twelve Layers of Encoders"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/pdf/1810.04805.pdf",children:(0,t.jsx)(n.strong,{children:"BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding"})})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"After the introduction of the Transformer architecture, many researchers began exploring ways to better utilize it. GPT-1, discussed previously, opted for a decoder-only architecture. In contrast, BERT chose an encoder-only approach."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Before BERT, there was a model called ELMo, released half a year earlier. Following the naming of BERT, researchers started a trend of naming models after Sesame Street characters. Initially, researchers seriously used titles to find acronyms, but later, they let their creativity fly, naming models whatever they liked..."})}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-problem",children:"Defining the Problem"}),"\n",(0,t.jsx)(n.p,{children:"There are generally two strategies for applying pre-trained language models to downstream tasks:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Feature-based methods:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Examples like ELMo (",(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/1802.05365",children:"Peters et al., 2018a"}),") use task-specific architectures that include pre-trained representations as additional features."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Fine-tuning methods:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Examples like OpenAI GPT introduce minimal task-specific parameters and train on the downstream tasks by simply fine-tuning all pre-trained parameters."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:'Both methods share the same objective function during pre-training, using a single language model to learn general language representations. The authors highlight a significant issue with the "unidirectionality" of such models.'}),"\n",(0,t.jsx)(n.h3,{id:"unidirectionality",children:"Unidirectionality"}),"\n",(0,t.jsx)(n.p,{children:"In OpenAI GPT, a left-to-right architecture is used, where each token can only attend to previous tokens in the Transformer\u2019s self-attention layers. This limitation is not ideal for sentence-level tasks and can be particularly detrimental when applying fine-tuning methods to token-level tasks, such as question answering, where incorporating context from both directions can significantly enhance performance."}),"\n",(0,t.jsx)(n.h2,{id:"solving-the-problem",children:"Solving the Problem"}),"\n",(0,t.jsx)(n.h3,{id:"model-architecture",children:"Model Architecture"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Model Architecture",src:s(25328).A+"",width:"1224",height:"396"})}),"\n",(0,t.jsx)(n.p,{children:"The proposed model architecture consists of 12 layers of encoders. The configurations are as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"BERT-Base:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"12 encoder layers, each following the basic Transformer structure."}),"\n",(0,t.jsx)(n.li,{children:"Each encoder layer has 768 hidden dimensions and 12 attention heads."}),"\n",(0,t.jsx)(n.li,{children:"Total parameter count is 110M."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"BERT-Large:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"24 encoder layers, each following the basic Transformer structure."}),"\n",(0,t.jsx)(n.li,{children:"Each encoder layer has 1024 hidden dimensions and 16 attention heads."}),"\n",(0,t.jsx)(n.li,{children:"Total parameter count is 340M."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For input data, BERT uses several strategies:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Flexible definition of input sequences:"}),' In BERT, a "sentence" can refer to any range of continuous text, and "sequence" refers to the input token sequence BERT processes, which may include one or two sentences.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"WordPiece embeddings:"})," Using a 30,000-token WordPiece vocabulary (",(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/1609.08144",children:(0,t.jsx)(n.strong,{children:"Wu et al., 2016"})}),") to handle unknown or rare words effectively."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Special tokens:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"[CLS] token:"})," The first token of every sequence, used as the representation for classification tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"[SEP] token:"})," Used to separate pairs of sentences, helping BERT distinguish and process information from different sentences."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"[MASK] token:"})," Used in pre-training to randomly mask some tokens for the model to predict."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sentence separation features:"})," Besides the [SEP] token, BERT adds learned parameters to each token to indicate whether it belongs to sentence A or B."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pre-training-strategy",children:"Pre-training Strategy"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"BERT Pre-training",src:s(9055).A+"",width:"1224",height:"488"})}),"\n",(0,t.jsx)(n.p,{children:"As shown in the image above, the left side represents BERT\u2019s pre-training strategy, and the right side represents the fine-tuning strategy. BERT's pre-training strategy is highly influential and has shaped the design of many subsequent models."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Masked Language Model (MLM):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"BERT uses the masked language model (also known as the cloze task) to train deep bidirectional representations. In this task, a certain percentage of input tokens are randomly masked, and the goal is to predict these masked tokens."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Random masking strategy:"})," About 15% of WordPiece tokens in each input sequence are randomly selected for masking. In 80% of cases, selected tokens are replaced with the [MASK] token, in 10% of cases with random tokens, and in the remaining 10% of cases, they are kept unchanged."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Predicting masked tokens:"})," For each masked token, BERT uses the corresponding final hidden vector through an output softmax layer to predict the original token, similar to traditional language models."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mitigating pre-training and fine-tuning mismatch:"})," Since [MASK] tokens are used during pre-training but not during fine-tuning, this creates a theoretical mismatch. BERT mitigates this by not always replacing selected tokens with actual [MASK] tokens but instead using a random strategy."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Next Sentence Prediction (NSP):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"To help the model better understand and capture sentence relationships, BERT introduces the next sentence prediction pre-training task."}),"\n",(0,t.jsx)(n.li,{children:"During pre-training, when selecting sentences A and B to form input pairs, there is a 50% chance that B is the actual next sentence following A (labeled as IsNext), and a 50% chance that B is a random sentence from the corpus (labeled as NotNext). This design helps the model learn to recognize whether two sentences are logically connected or sequentially ordered."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"fine-tuning-strategy",children:"Fine-tuning Strategy"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"BERT Fine-tuning",src:s(9055).A+"",width:"1224",height:"488"})}),"\n",(0,t.jsx)(n.p,{children:"In the fine-tuning stage, BERT adds an additional classification layer for downstream tasks."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Question Answering (SQuAD):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In question answering tasks, BERT processes the question and the paragraph containing the answer as a single sequence, using different embeddings to identify the question and paragraph parts. During fine-tuning, BERT introduces specific start and end vectors to predict the answer's position within the paragraph."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Natural Language Inference (NLI):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In NLI tasks, BERT takes two sentences as input and predicts the relationship between them by connecting their representations and passing them through a classification layer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This fine-tuning method is relatively low-cost and can be completed within hours on a GPU or Cloud TPU, making BERT particularly suitable for quickly deploying and achieving high-performance solutions for various natural language processing tasks."}),"\n",(0,t.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"BERT Results",src:s(994).A+"",width:"1224",height:"280"})}),"\n",(0,t.jsx)(n.p,{children:"On the GLUE benchmark tasks, BERT significantly outperformed the OpenAI GPT model, especially on the MNLI task, where BERT-LARGE achieved a score of 80.5, compared to GPT\u2019s 72.8. Studies also showed that BERT-LARGE performed better than BERT-BASE on tasks with smaller datasets, indicating that model size plays a crucial role in improving performance."}),"\n",(0,t.jsx)(n.p,{children:"Moreover, BERT set new state-of-the-art results on 11 different NLP tasks, demonstrating its versatility and effectiveness across various tasks."}),"\n",(0,t.jsx)(n.h3,{id:"ablation-study",children:"Ablation Study"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"BERT Ablation",src:s(2577).A+"",width:"968",height:"414"})}),"\n",(0,t.jsx)(n.p,{children:"The authors conducted a series of ablation studies to explore the impact of different components of BERT on performance."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Without NSP:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A bidirectional model trained with only the Masked LM (MLM) objective and no next sentence prediction (NSP). Results showed that the absence of NSP significantly harmed performance on QNLI, MNLI, and SQuAD 1.1."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"LTR & Without NSP:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A model trained with a left-to-right (LTR) language model without MLM or NSP. This model underperformed the MLM model across all tasks, especially on MRPC and SQuAD."}),"\n",(0,t.jsx)(n.li,{children:"On SQuAD, the LTR model\u2019s token prediction performance was significantly worse due to the lack of right-side context support."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Adding BiLSTM:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"To improve the LTR system, a randomly initialized BiLSTM was added. While BiLSTM improved SQuAD performance, it was still far from matching the bidirectional model and negatively impacted GLUE tasks."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Comparison with ELMo\u2019s Strategy:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Separate LTR and RTL models were trained and their outputs concatenated, similar to ELMo\u2019s approach. Although this strategy utilized both left and right context, it required double the cost of a single bidirectional model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"BERT\u2019s prominence comes from its high performance. During that era, achieving such state-of-the-art results across numerous benchmarks was rare, which brought significant attention to BERT. After BERT\u2019s introduction, the academic community shifted away from LSTM, with the focus heavily leaning towards Transformer architectures."}),"\n",(0,t.jsx)(n.p,{children:'BERT\u2019s success demonstrated the potential of the "pre-training-fine-tuning paradigm" for various natural language understanding tasks, laying the groundwork for even more powerful models in the future.'})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},25328:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/img1-41bfb99df10461370d0216ae59469093.jpg"},9055:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/img2-1567224d4a4076c2fca6a71489194baf.jpg"},994:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/img3-3d722e11e4894c16e56c1da28cc4c70d.jpg"},2577:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/img4-b6a0c39f58bb03bff44d2f62db5f9039.jpg"},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);