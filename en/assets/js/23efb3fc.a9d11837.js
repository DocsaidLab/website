"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7259],{5347:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var t=i(74848),s=i(28453);const r={},a="[20.10] ViT",o={id:"vit/index",title:"[20.10] ViT",description:"Pioneering a New World",source:"@site/i18n/en/docusaurus-plugin-content-docs-papers/current/2010-vit/index.md",sourceDirName:"2010-vit",slug:"/vit/",permalink:"/en/papers/vit/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"zephyr-sh",lastUpdatedAt:1720828419e3,frontMatter:{},sidebar:"papersSidebar",previous:{title:"[20.10] AutoPrompt",permalink:"/en/papers/autoprompt/"},next:{title:"[20.12] DeiT",permalink:"/en/papers/deit/"}},l={},h=[{value:"Pioneering a New World",id:"pioneering-a-new-world",level:2},{value:"Problem Definition",id:"problem-definition",level:2},{value:"Solution",id:"solution",level:2},{value:"Model Architecture",id:"model-architecture",level:3},{value:"Patchify",id:"patchify",level:3},{value:"And Then?",id:"and-then",level:3},{value:"Lack of Inductive Bias",id:"lack-of-inductive-bias",level:3},{value:"Training Data Must Be Large",id:"training-data-must-be-large",level:3},{value:"Can Be Even Larger",id:"can-be-even-larger",level:3},{value:"Discussion",id:"discussion",level:2},{value:"What Does ViT See?",id:"what-does-vit-see",level:3},{value:"Predict with [CLS] or GAP?",id:"predict-with-cls-or-gap",level:3},{value:"Other Considerations",id:"other-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"2010-vit",children:"[20.10] ViT"}),"\n",(0,t.jsx)(n.h2,{id:"pioneering-a-new-world",children:"Pioneering a New World"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2010.11929",children:(0,t.jsx)(n.strong,{children:"An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale"})})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"The following content is compiled by ChatGPT-4 and has been manually checked, edited, and supplemented."})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"In 2017, the introduction of the Transformer model caused a massive wave in the field of natural language processing (NLP), quickly becoming a dominant force."}),"\n",(0,t.jsx)(n.p,{children:"Three years later, this wave has finally reached the realm of computer vision."}),"\n",(0,t.jsx)(n.h2,{id:"problem-definition",children:"Problem Definition"}),"\n",(0,t.jsx)(n.p,{children:"In recent years, many studies have attempted to integrate attention mechanisms with convolutional networks."}),"\n",(0,t.jsx)(n.p,{children:"Or they have replaced certain parts while keeping the convolutional network's structure unchanged."}),"\n",(0,t.jsx)(n.p,{children:"These studies suggest that the Transformer architecture cannot be directly applied to the image domain without modification."}),"\n",(0,t.jsx)(n.p,{children:"However, the authors of this paper argue:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"That's because you're doing it wrong!"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We can completely abandon convolutions and directly use Transformers to process images."}),"\n",(0,t.jsx)(n.p,{children:"Processing images is merely a matter of handling a collection of 16 x 16 words!"}),"\n",(0,t.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,t.jsx)(n.h3,{id:"model-architecture",children:"Model Architecture"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"arch",src:i(81022).A+"",width:"1472",height:"772"})}),"\n",(0,t.jsx)(n.p,{children:"We are all familiar with the Transformer architecture."}),"\n",(0,t.jsx)(n.p,{children:"You embed the text, arrange it into a sequence, pass it through an encoder, then through a decoder, and finally get the output."}),"\n",(0,t.jsx)(n.p,{children:"When applying this structure to images, the first question to consider is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"How do you convert images into a sequence of words?"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here, the authors propose a method: patch it up!"}),"\n",(0,t.jsx)(n.h3,{id:"patchify",children:"Patchify"}),"\n",(0,t.jsx)(n.p,{children:"Given an image with dimensions 224 x 224, how would you divide it into smaller regions?"}),"\n",(0,t.jsx)(n.p,{children:"Manually cut it? Of course not!"}),"\n",(0,t.jsx)(n.p,{children:"The authors introduce a Conv2d operation to accomplish this task."}),"\n",(0,t.jsx)(n.p,{children:"Let's implement it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import torch\nimport torch.nn as nn\n\n# Assume image size is 224 x 224\ndummy_img = torch.randn(1, 3, 224, 224)\n\n# Patch size\npatch_size = 16\n\n# Embedding dimension\nembed_dim = 768\n\n# Patchify\nemb_layer = nn.Conv2d(3, embed_dim, kernel_size=patch_size, stride=patch_size)\n\n# After patching:\n# input.shape = (1, 3, 224, 224)\n# tokens.shape = (1, 768, 14, 14)\ntokens = emb_layer(dummy_img)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Here, we set the patch size to 16 x 16 and the embedding dimension to 768."}),"\n",(0,t.jsx)(n.p,{children:"Using the stride in the convolution, we can slide across the image in non-overlapping windows, dividing the 224 x 224 image into 14 x 14 patches."}),"\n",(0,t.jsx)(n.p,{children:"In the original Transformer, each token in the text sequence is embedded. Here, we do the same: each image patch is embedded, meaning each 16 x 16 x 3 region is linearly transformed into a 768-dimensional vector."}),"\n",(0,t.jsx)(n.p,{children:"Finally, we flatten these patches into a sequence:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"tokens = tokens.flatten(2) # (1, 768, 14, 14) -> (1, 768, 196)\ntokens = tokens.permute(2, 0, 1) # (1, 768, 196) -> (196, 1, 768)\n"})}),"\n",(0,t.jsx)(n.p,{children:"In the Transformer encoder, the input's first dimension is the sequence length, the second dimension is the batch size, and the third dimension is the feature encoding length."}),"\n",(0,t.jsx)(n.p,{children:"With the above operations, we get the input sequence ready for the Transformer."}),"\n",(0,t.jsx)(n.h3,{id:"and-then",children:"And Then?"}),"\n",(0,t.jsx)(n.p,{children:"That's it."}),"\n",(0,t.jsx)(n.p,{children:"From here, you can treat it like any other NLP Transformer."}),"\n",(0,t.jsx)(n.p,{children:"Wait, not so fast!"}),"\n",(0,t.jsx)(n.p,{children:"Below is the parameter setting for ViT:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"params",src:i(5356).A+"",width:"1224",height:"332"})}),"\n",(0,t.jsx)(n.h3,{id:"lack-of-inductive-bias",children:"Lack of Inductive Bias"}),"\n",(0,t.jsx)(n.p,{children:"In the Transformer architecture, there is no inductive bias for images."}),"\n",(0,t.jsx)(n.p,{children:"In ViT, only the MLP layers are local and translation-invariant, while the self-attention mechanism is global, with very little 2D neighborhood structural information."}),"\n",(0,t.jsx)(n.p,{children:"Therefore, the model must learn from scratch and understand: what is an image? What are the features of an image?"}),"\n",(0,t.jsx)(n.p,{children:"This is why it took so long to move from Transformers to ViT; early research failed to outperform convolutional networks and was thus abandoned."}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What is the inductive bias of convolutional networks?"})}),(0,t.jsx)(n.p,{children:"The inductive bias of convolutional networks refers to their design preference for the translational invariance and locality of images. This preference is realized through the convolutional kernels, whose shared weights and local receptive fields enable convolutional networks to capture local features of images and perform well in tasks involving the translational invariance of images, making them easily generalizable to other image recognition tasks."})]}),"\n",(0,t.jsx)(n.h3,{id:"training-data-must-be-large",children:"Training Data Must Be Large"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"data",src:i(60617).A+"",width:"1224",height:"748"})}),"\n",(0,t.jsx)(n.p,{children:"Experiments show that if the training dataset is not large enough, ViT performs significantly worse than convolutional networks."}),"\n",(0,t.jsx)(n.p,{children:"In the figure, the gray lines represent ResNet50x1 (BiT) and ResNet152x2 (BiT) results, while other colored lines represent ViT results. The horizontal axis shows the amount of training data, and when the data reaches 300M, ViT finally outperforms convolutional networks."}),"\n",(0,t.jsx)(n.p,{children:"The authors believe:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"For small datasets, the inductive bias of convolutional networks is crucial."})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"For large datasets, learning relevant patterns directly from the data is sufficient!"})}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"Understanding ViT models:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ViT-L/16: Large model with 16 x 16 patches"}),"\n",(0,t.jsx)(n.li,{children:"ViT-L/32: Large model with 32 x 32 patches"}),"\n"]}),(0,t.jsx)(n.p,{children:"The smaller the patch size, the higher the encoding resolution, resulting in better performance but higher computational cost, growing quadratically."})]}),"\n",(0,t.jsx)(n.h3,{id:"can-be-even-larger",children:"Can Be Even Larger"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"scale",src:i(95319).A+"",width:"1224",height:"524"})}),"\n",(0,t.jsx)(n.p,{children:"What happens if we keep training?"}),"\n",(0,t.jsx)(n.p,{children:"In this experiment, the authors used three different models:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ViT"}),"\n",(0,t.jsx)(n.li,{children:"ResNet"}),"\n",(0,t.jsx)(n.li,{children:"Hybrid Model"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Results show that with enough training data, ViT outperforms ResNet."}),"\n",(0,t.jsx)(n.p,{children:"Moreover, the Hybrid Model performs slightly better than ViT with smaller models, but this difference disappears as the model size increases."}),"\n",(0,t.jsx)(n.p,{children:"Finally, ViT shows no sign of saturation within the tested range, indicating more potential to be explored."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"One might expect that convolutional local feature processing would help any size of ViT, but it doesn't."})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"result",src:i(24154).A+"",width:"1224",height:"608"})}),"\n",(0,t.jsx)(n.h2,{id:"discussion",children:"Discussion"}),"\n",(0,t.jsx)(n.h3,{id:"what-does-vit-see",children:"What Does ViT See?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"what",src:i(28357).A+"",width:"1654",height:"500"})}),"\n",(0,t.jsx)(n.p,{children:"The authors extracted the first layer's projection of image patches into low-dimensional space, displaying the first 28 principal components."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Self-attention (left)"})}),"\n",(0,t.jsx)(n.p,{children:"ViT, through the self-attention mechanism, can integrate global information from the image even in the lowest layer."}),"\n",(0,t.jsx)(n.p,{children:"Attention weights are used to calculate the average distance of integrated information in the image space, similar to the receptive field size in CNNs."}),"\n",(0,t.jsx)(n.p,{children:"The model shows broad attention in the lowest layer, indicating its ability to integrate global information. Other attention heads focus more locally in lower layers."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Position Embeddings (center)"})}),"\n",(0,t.jsx)(n.p,{children:"Patches that are spatially close have similar embeddings, indicating that these embeddings can encode the distance relationships between patches within the image."}),"\n",(0,t.jsx)(n.p,{children:"The embeddings show row-column structures, sometimes revealing significant sinusoidal structures for larger grids."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Attention Distance (right)"})}),"\n",(0,t.jsx)(n.p,{children:'This "attention distance" is akin to the receptive field size in CNNs.'}),"\n",(0,t.jsx)(n.p,{children:"The average attention distance varies greatly across different heads in lower layers; some heads focus on most of the image, while others concentrate on the query position or nearby small regions."}),"\n",(0,t.jsx)(n.p,{children:"As depth increases, the attention distance of all heads grows. In the network's latter half, most heads have long attention distances, indicating a focus on global information in these layers."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"predict-with-cls-or-gap",children:"Predict with [CLS] or GAP?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"cls",src:i(84392).A+"",width:"1224",height:"598"})}),"\n",(0,t.jsx)(n.p,{children:"In this paper, the authors used two different methods for classification tasks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"[CLS] Prediction"})}),"\n",(0,t.jsx)(n.p,{children:"This is common in NLP, using the first token of the sequence to represent the entire sequence."}),"\n",(0,t.jsx)(n.p,{children:"This approach also works well in the image domain."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"GAP Prediction"})}),"\n",(0,t.jsx)(n.p,{children:"GAP (Global Average Pooling) is a common feature extraction method, averaging each channel of the feature map to obtain a vector."}),"\n",(0,t.jsx)(n.p,{children:"Initially, the authors used this method but found it performed very poorly!"}),"\n",(0,t.jsx)(n.p,{children:'Detailed analysis revealed the issue wasn\'t GAP itself but the "learning rate" being too high!'}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"After adjustments, both prediction methods achieved good results."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"In our experience, the Transformer architecture is very sensitive to learning rates, and this holds true for ViT."})}),"\n",(0,t.jsx)(n.h3,{id:"other-considerations",children:"Other Considerations"}),"\n",(0,t.jsx)(n.p,{children:"Besides the main content, here are some training tips and considerations:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Using a weight decay of 0.1 for training was found beneficial for downstream tasks."}),"\n",(0,t.jsx)(n.li,{children:"The authors imitated MLM training methods but found them ineffective, requiring further research."}),"\n",(0,t.jsx)(n.li,{children:"When the input image resolution changes, corresponding changes in the input sequence length (due to fixed patch size) necessitate linear interpolation of learned position encodings."}),"\n",(0,t.jsx)(n.li,{children:"Adam was found to work better than SGD, likely because Adam better handles learning rate issues (AdamW is now commonly used)."}),"\n",(0,t.jsx)(n.li,{children:"Using 1-D learnable position encodings, 2-D learnable position encodings, or relative position encodings showed little difference, but one must be chosen; otherwise, performance significantly drops."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"This paper explores the application of Transformers to the image domain, proposing a novel architecture, ViT."}),"\n",(0,t.jsx)(n.p,{children:"ViT outperforms traditional convolutional networks on large datasets and demonstrates greater potential in experiments."}),"\n",(0,t.jsx)(n.p,{children:"The publication of this paper marks the successful application of the Transformer architecture in the image domain, opening new directions for future research."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},81022:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img1-e4df6921f628ba6819ec9fc778d6150e.jpg"},60617:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img2-c1d80181e8e6a9afb5e7c4b1ed9f0941.jpg"},5356:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img3-c3e287a1c047ee24e5f254dec9bff6b7.jpg"},95319:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img4-c6486156c2adc483b4526e2ec9f41f29.jpg"},24154:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img5-e3e59b7769f43255b07a34b40a54aa2c.jpg"},28357:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img6-51c223d1ccba5bf64a36cb3c07e9fdd2.jpg"},84392:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/img7-493ec8fcb301917eb825b68df3dd31bb.jpg"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);